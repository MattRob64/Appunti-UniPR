UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
Dispensa -L1 - Introduzione all'Ingegneria del Software
Prof. Agostino Poggi
A.A. 2024/2025

Glossario
Dominio applicativo: i sistemi software che si possono realizzare hanno
caratteristiche differenti e quindi il loro sviluppo implica la conoscenza
delle caratteristiche del sistema da realizzare e dell'ambiente in cui si trova.
Queste conoscenze possono essere identificate tramite l'analisi del
dominio che ha l'obiettivo di comprendere a fondo i concetti, le dinamiche,
le regole generali che definiscono il dominio applicativo in cui il sistema
software dovrà essere impiegato, ovvero il contesto in cui il software dovrà
agire. L'analisi del dominio deve quindi essere condotta congiuntamente
da analisti ed esperti del dominio (e.g., i clienti stessi che commissionano
lo sviluppo del sistema, e/o i probabili utenti del sistema stesso).
Funzionalità: è un servizio che il sistema dovrebbe fornire. La sua
descrizione dovrebbe indicare come il sistema deve reagire a particolari
input e come il sistema deve comportarsi in situazioni particolari.
Requisiti: sono le descrizioni dei servizi che un sistema software deve
fornire e dei vincoli in base ai quali deve operare.
Specifica: è una descrizione precisa dei requisiti
(proprietà o
comportamenti richiesti) di un sistema o di una sua parte.
Stakeholder: Sono le persone che in qualche modo sono interessate a un
sistema. Possono essere ingegneri, programmatori che stanno sviluppando
il sistema o mantenendo sistemi correlati, manager aziendali, esperti di
dominio e rappresentanti sindacali. Possono anche essere gli utenti finali
che interagiscono con il sistema e tutti gli altri membri di un'organizzazione
che potrebbero essere interessati dalla sua installazione.
Caratteristiche e legami dell'ingegneria del software
Definizione di Ingegneria del Software - Si basa su un insieme di tecniche,
metodologie e strumenti. Ha l'obiettivo di produrre sistema software di
alta qualità che soddisfano: il budget a disposizione, la data di scadenza del

rilascio del sistema, e una corretta gestione dei cambiamenti che possono
essere necessari durante lo sviluppo.
Ingegneria del Software e Risoluzione dei Problemi
Utilizza le tecniche di risoluzione dei problemi attraverso una fase di analisi
(in cui si cerca di comprendere la natura del problema e di come suddividilo
in parti) e una fase di sintesi (in cui si Integrano tra loro le parti per ottenere
il sistema finale
Relazioni con Altre Discipline
Ha forti legami con: i linguaggi si programmazione, i sistemi operativi, le
basi di dati, i modelli teorici e l'intelligenza artificiale. Ha dei legami con: le
scienze organizzative e l'ingegneria dei sistemi. Le scienze organizzative
studiano come funzionano non solo le imprese e le amministrazioni
pubbliche ma anche tutte le realtà che perseguono interessi economici,
politici, sociali e culturali: dalle agenzie governative alle associazioni di
rappresentanza, dai partiti politici alle istituzioni formative, dalle realtà no
profit all'Unione Europea fino ai sistemi produttivi locali e i territori.
Grazie all'analisi degli aspetti sociali, economici e giuridici di
un'organizzazione, gli esperti nel campo dell'organizzazione intervengono
sui malfunzionamenti, sulle inefficienze, sui fallimenti e sugli errori; infine,
gli esperto di organizzazione, risorse umane e sviluppo, elaborano le
strategie per migliorare efficacia, efficienza, qualità, affidabilità e
sostenibilità delle organizzazioni, sulla base di conoscenze sociologiche,
economico-aziendali e giuridiche.
L'ingegneria dei sistemi è un campo complesso dell'ingegneria e della
gestione ingegneristica che richiede una comprensione completa dei suoi
processi, strumenti e ruoli. Seguendo i principi e le best practice
dell'ingegneria dei sistemi, le organizzazioni possono garantire che i loro
sistemi siano progettati, sviluppati e mantenuti correttamente. Un
ingegnere di sistemi è responsabile della progettazione e
dell'implementazione dei sistemi informatici. Questo include i componenti
hardware, software, di rete e di archiviazione del sistema. Il sistemista deve

garantire che il sistema soddisfi le esigenze degli utenti e sia in grado di
gestire il carico di lavoro.
Particolarità del software
Il software è immateriale. L'immaterialità del software fa sì che sia difficile
visualizzare i concetti che gli sono propri, come algoritmi, strutture dati, e
flussi di controllo. In effetti, una buona parte dell'ingegneria del software
*e rivolta allo studio e all'applicazione di notazioni espressive e sintetiche
per rappresentare tali concetti.
Il software richiede spesso l'utilizzo di sistemi ad alta intensità umana. Gli
ingegneri in genere progettano questi sistemi in modo da funzionare come
previsto una volta completato lo sviluppo. Tuttavia, questi sistemi possono
essere molto complessi e spesso richiedono l'intervento umano per
decidere e agire. L'intervento umano è l'elementi chiave del successo di
questi sistemi, ma una buona parte dei malfunzionamenti è dovuta
all'errore umano.
Il software è estremamente malleabile, cioè modificabile con pochissimo
sforzo. Questa proprietà è un vantaggio ma anche un pericolo, poiché
incoraggia un modo di lavorare non pianificato
Il software 'e complesso: un programma può essere composto da un
numero grandissimo di istruzioni, e ciascuna di esse potenzialmente
condiziona il comportamento di tutte le altre.
Il software è "non lineare", nel senso che un piccolo cambiamento nel
codice può portare a grandi cambiamenti (spesso indesiderati!) nel
funzionamento di un'applicazione

Attività principali dell'Ingegneria del software
La realizzazione di sistemi software coinvolge cinque attività principali: lo
studio di fattibilità, la definizione delle specifiche del software, lo sviluppo
del software, la verifica del software e l'evoluzione del software.
La prima attività è lo studio di fattibilità. Quest'attività stabilisce se il
sistema può essere realizzato e se è conveniente realizzarlo. Per prendere
una decisione è necessario: i) eseguire un'analisi approfondita del dominio
applicativo, ii) definire le possibili strategie e modalità di sviluppo che
possono essere adottate per realizzarlo, iii) valutare le risorse e i costi delle
diverse alternative e una previsione sulle possibili durate dello sviluppo del
sistema (ogni alternativa può corrispondere a una diversa durata).
La seconda attività è la definizione delle specifiche del software.
Quest'attività coinvolge i clienti e gli ingegneri e ha lo scopo di definire il
sistema software che deve essere prodotto e i vincoli sul suo
funzionamento.
La terza attività è lo sviluppo software, partendo dalle specifiche, gli
ingegneri e gli sviluppatori progettato e scrivono il software del sistema.
La quarta attività è la verifica. Quest'attività ha l'obiettivo di controllare se
il funzionamento del sistema è corretto, e se tutte le richieste del cliente
sono state soddisfatte. In particolare, queste richieste sono in gran parte
definite nella fase di definizione delle specifiche, ma il cliente spesso può
chiedere la modifica di una sua precedente richiesta o l'aggiunta di nuove
richieste.
Infine, la quinta attività è l'evoluzione del software. Quest'attività che
viene eseguita dopo il rilascio del software al cliente e ha lo scopo di: i)
correggere gli eventuali bug, che possono essere individuati dal cliente o
dagli utenti del sistema, ii) fare dei cambiamenti nel software del sistema
in base alla richiesta del cliente e iii) aggiungere delle nuove funzionalità
sempre del sistema in base alla richiesta del cliente.

Proprietà del Software
Come tutti i tipi di sistemi, un sistema software deve garantire delle buone
qualità e un corretto funzionamento. In particolare, il software di un
sistema dovrebbe soddisfare un bel numero di proprietà.
La correttezza indica la capacità del software di rispondere ai requisiti
funzionali e non funzionali, a fronte di input corretti, il software produce il
risultato atteso.
L'affidabilità indica la probabilità che il software si comporti nel modo
atteso in un certo intervallo di tempo.
La robustezza indica la capacità del software di funzionare anche in
situazioni anomale non previste dai requisiti.
Le prestazioni hanno spesso una valutazione dipendente dal sistema da
realizzare e dalle persone interessate al sistema (stakeholder). Infatti,
viene indicata come una qualità esterna basata sui requisiti dell'utente,
e.g., quanti accessi contemporanei attesi, quale velocità di risposta attesa,
etc.
L'efficienza è una qualità interna che valuta l'utilizzo delle risorse del
calcolatore (hardware e software). L'obiettivo è minimizzare l'uso delle
risorse e massimizzare le prestazioni.
La scalabilità indica la capacità del software di crescere in relazione al livello
di utilizzo (e.g., attraverso l'aggiunta o la riduzione di hardware e software).
L'usabilità indica la facilità di utilizzo e di apprendimento del sistema
software da parte degli utenti.
La verificabilità indica la capacità di individuare se il sistema software
funziona correttamente e se le richieste del cliente sono state soddisfatte.
Per garantire la verificabilità è quasi sempre necessario avere a
disposizione degli strumenti che consentono un monitoraggio del software
(uso strumenti di analisi e testing).

La manutenibilità indica la possibilità di poter correggere e/o migliorare il
sistema software dopo il suo rilascio al cliente.
La riusabilità indica la capacità del software di essere riutilizzato, anche in
parte, per applicazioni diverse.
La portabilità indica la capacità del software di essere eseguito in ambienti
diversi (hardware o software).
La comprensibilità indica, che la documentazione e il software permettono
agli stakeholder del sistema da realizzare di comprendere quali saranno le
caratteristiche del sistema software da realizzare e come il software è stato
realizzato.
L' interoperabilità indica la capacità del software di coesistere e cooperare
con altri sistemi
La produttività fornisce una valutazione dell'efficienza e delle prestazioni
del processo di produzione e consegna del prodotto nel tempo stabilito e
secondo il budget previsto
La tempestività richiede che il processo di produzione deve rendere
disponibile il prodotto nel momento giusto.
La trasparenza richiede che tutte le fasi e parti del processo di produzione
devono essere documentate e rese disponibili|
Capacità necessarie per lo sviluppo di software
Richiede le più diverse attività e capacità: risolvere dei problemi, acquisire
delle conoscenze, prendere delle decisioni, astrarre oggetti e sistemi,
definire dei modelli, etc.
Capacità e Conoscenze dell'Ingegnere del software
Un ingegnere del software deve essere un buon programmatore, un
esperto in strutture dati e algoritmi e in uno o più linguaggi di
programmazione, deve essere familiare con le differenti area applicative e
con più approcci di progettazione, deve essere capace a muoversi tra i
diversi livelli di astrazione di un progetto e nel costruire diverse varietà di
8

modelli, deve essere in grado di fare scelte tra le possibili soluzioni
disponibili e di comunicare e interagire con le persone, e infine, deve essere
in grado di tradurre descrizioni e risposte (in genere del cliente) anche
vaghe in precise specifiche.
Ruoli nello sviluppo del software
Il cliente ha il compito di fornire una buona descrizione del sistema
software
che
vorrebbe sia realizzato. Inoltre, il cliente ha diverse
responsabilità e potrebbe essere coinvolto durante le attività di
realizzazione del sistema. In particolare, dovrebbe partecipare attivamente
alla raccolta, revisione e approvazione dei requisiti e dei documenti di
progettazione e sviluppo in modo da garantire che le sue richieste siano
inserite correttamente nella documentazione, infine, durante tutto il
processo di sviluppo del sistema software, dovrebbe fornire feedback
regolari e rispondere alle domande degli altri stakeholder.
Il gestore del progetto (manager) è la persona che ha la responsabilità di
un progetto, valuta le necessità dei clienti e decide le scelte organizzative
necessarie per raggiungere l'obiettivo richiesto.
L'analista si occupa principalmente di analizzare i possibili problemi del
sistema software che si deve sviluppare (fase di analisi) e di identificare le
possibili soluzioni per sviluppare il sistema e per soddisfare le richieste del
cliente (fase di programmazione). In particolare, un analista deve
raccogliere le richieste del cliente, valutare la fattibilità della realizzazione
del sistema software e, durante lo sviluppo, valutare la fattibilità di
effettuare delle modifiche o l'aggiunta di nuove funzionalità richieste (in
genere) dal cliente.
Il programmatore ha delle conoscenze ampie e specifiche nei principali
linguaggi di programmazione e nelle tecniche di sviluppo del software.
Il gestore dei test (test engineering o tester) si occupano del controllo delle
correttezza e della qualità del software. In particolare, in base alle
specifiche fornite dall'analista e dal programmatore, realizza dei piani di
test, prepara i dati da utilizzare nei test ed esegue i test. Infine, si occupa,

della stesura della documentazione relativa ai risultati dei test, evidenzia le
anomalie e, se possibile, propone possibili soluzioni.
Il consulente in genere è una persona esterna all'azienda che deve
sviluppare un sistema software e ha il compito di fornire una guida nella
scelta degli strumenti e delle tecnologie più adatte per risolvere i problemi
di progettazione e sviluppo quando il personale dell'azienda ha difficoltà a
risolvere questi problemi.
L'utente ha il compito di: i) eseguire dei comandi per garantire il corretto
funzionamento dei processi del sistema software, ii) segnalare i possibili
malfunzionamenti, e ili) ripristinare il funzionamento del sistema in caso di
"failure" del sistema, etc.
Responsabilità professionale ed etica
L'ingegneria del software comporta responsabilità più ampie rispetto alla
semplice applicazione di competenze tecniche. Il comportamento etico va
oltre il semplice rispetto della legge. In particolare ogni persona coinvolta
in un progetto dovrebbe: comportarsi in modo onesto ed eticamente
responsabile e offrire competenza e riservatezza.
Sistemi software
Sono dei sistemi che utilizzano componenti, hardware e software. Hanno
l'obiettivo di soddisfare le esigenze dei clienti. In particolare, questi sistemi
possono essere realizzati in diverse versioni (e.g., versioni aggiornate dei
sistemi). Un sistema software di successo può rimanere in servizio per
parecchi anni e, durante la sua vita, può subire numerose modifiche e
estensioni (e.g., l'aggiunta di nuove funzionalità).
Stima dei Costi del Software
Due tipi di metriche: dimensionali e funzionali
La stima del costo basato sulle metriche dimensionali si basa su: il numero
di linee di codice prodotte, Il numero di istruzioni in "linguaggio macchina"
e Il numero di pagine di documentazione del sistema.
10

La stima del costo basato sulle metriche funzionali si basa su: i) il numeri di
classi, attributi, relazioni, metodi, messaggi, parametri dei messaggi,
sorgenti e destinazioni dei messaggi e percentuale di riuso e ii) il numero
di oggetti, complessità di ciascun oggetto, percentuale
di riuso e
produttività.
Distribuzione dei Costi di un Sistema Software
Figura 1. distribuzione dei costi di sviluppo di un sistema software.
Dominio applicativo o del problema
In ingegneria del software e in altre discipline informatiche, per dominio
applicativo (o dominio del problema) s'intende il contesto in cui opera
un'applicazione, specie con riferimento al tipo e al significato delle
informazioni da elaborare. Il problema sostanziale è che oggigiorno sono
disponibili diversi tipi di sistemi software e ognuno di questi può avere
caratteristiche differenti. Quindi per limitare i problemi dello sviluppo di un
sistema è necessario avere delle buone conoscenze del suo dominio
applicativo. Queste conoscenze possono essere identificate tramite
l'analisi del dominio. Quest'analisi ha l'obiettivo di comprendere a fondo i
concetti, le dinamiche, le regole generali che definiscono il dominio
applicativo in cui il sistema software dovrà essere impiegato, ovvero il
contesto in cui il software dovrà agire. Ovviamente, la qualità dei risultati
dipende dal tipo di persone coinvolte, oltre a degli analisti sono coinvolti
anche esperti del dominio in questione. Tra gli esperti sono quasi sempre
coinvolti i clienti che hanno richiesto lo sviluppo del sistema, e potranno
essere coinvolti gli utenti di sistemi simili e i probabili utenti del sistema
stesso.
11

Ciclo di vita di un sistema software
Il ciclo di vita di un sistema software coinvolge in genere cinque attività
principali: l'analisi preliminare, la progettazione, la realizzazione, la
gestione e, infine, la messa fuori servizio del sistema.
L'attività di analisi preliminare ha l'obiettivo di identificare: le esigenze del
cliente, il contesto in cui sviluppare il sistema (l'ambiente in cui si trova il
sistema), il tipo di sistema che bisognera realizzare, e i requisiti che
bisognerà implementare. Da quest'analisi dovrebbe essere possibile
decidere la fattibilità della realizzazione del sistema software
L'attività di progettazione ha l'obiettivo di fornire una documentazione
(integrata da diagrammi) che definisce le specifiche funzionali ed
architetturali del sistema da realizzare, la scomposizione in moduli del
sistema, le risorse che si possono riusabili e, se necessario, le nuove risorse
che si dovrebbero acquisire.
L'attività di realizzazione ha l'obiettivo di completare e consegnare il
sistema realizzato. Oltre alle attività relative allo sviluppo del software del
sistema da realizzare, il software va raffinamento e testato, aumentando
la qualità del software sviluppato e riducendo la possibilità di avere un
sistema con diversi bug. Concluso lo sviluppo, il sistema è collaudato con il
cliente e i sui utenti. Se il collaudo ha successo, il sistema è messo in servizio
presso il cliente.
L'attività di gestione ha il compito di mantenere in funzione il sistema,
attraverso attività di manutenzione che correggono eventuali bug,
aggiornano hardware e/o software e, in genti casi, aggiungono nuove
funzionalità.
L'attività di messa fuori servizio ha l'obbiettivo di fare un backup dei dati
del sistema ed eventualmente di far migrare i dati e i servizi su nuovo
sistema.
Difficoltà dello sviluppo del software
12

Con il passare del tempo, l'evoluzione delle tecnologie software permette
lo sviluppo di sistemi sempre più complessi e quindi i sistemi che si vogliono
realizzare richiedono nuove competenze e capacità. Il processo di sviluppo
di un sistema software è difficile da gestire. Questo, in parte, è dovuto al
fatto che il software offre un'estrema flessibilità ed è un sistema discreto.
La flessibilità permette di modificare facilmente il software. Il software è
estremamente flessibile, cioè modificabile con pochissimo sforzo. Questa
proprietà è un vantaggio ma anche un pericolo, poiché incoraggia un modo
di lavorare non pianificato. La non linearità fa sì che un piccolo
cambiamento nel codice può portare a grandi cambiamenti (spesso
indesiderati) nel funzionamento di un'applicazione.
Lo sviluppo di un sistema software quasi sempre deve affrontare dei
problemi e le difficoltà da superare dipendono dalla complessità del
sistema da realizzare.. Quello che si dice in genere è che il dominio del
problema è quasi sempre difficile e anche Il dominio della soluzione
presenta dei problemi che sono difficili da risolvere. Le difficoltà nel
realizzare un sistema software sono spesso aumentate dagli obiettivi e
dalle richieste degli stakeholder.
Richieste più frequenti
Ad esempio, sono frequenti richieste di aggiunta e/o modifica di parti del
sistema e di richieste di riduzione dei tempi la consegna, Questo tipo di
richieste sono normali nello sviluppo di un sistema software, ma i risultati
dipendono dal peso (tempo in meno e lavora da fare) delle richieste.
Problemi tipici
Se il peso è eccessivo si potrebbero avere uno o più risultati negativi, ad
esempio, la consegna del sistema ritardata, lo sforamento del budget, la
bassa affidabilità e le basse prestazioni del sistema e, infine, le difficoltà
nella manutenzione e nell'aggiunta di funzionalità al sistema. Nel caso di
sistemi molto complessi, la presenza di diversi risultati negativi può
precedere un'elevate probabilità di ritiro del progetto di sviluppo.
Sfide dell'Ingegneria del software

Il successo dell'ingegneria del software per sviluppare sistemi non solo utili,
ma anche molto utilizzati può essere aiutato attraverso la valorizzazioni di
alcune proprietà: l'eterogeneità, il cambiamento sociale, la sicurezza e la
fiducia e l'evoluzione tecnologica. L' eterogeneità è la capacità di realizzare
sistemi integrando diversi tipi di software e/o hardware. Il cambiamento
sociale comporta un mutamento significativo della società dovuto in gran
parte dallo sviluppo tecnologico che offre sempre nuovi interessi. Infine,
la sicurezza e la fiducia sono due componenti che permettono a un cliente
e/o utente di valutare, in modo positivo o negativo, la possibilità di fare
delle scelte, e.g., l'uso o il non uso di un sistema, l'acquisto o il non acquisto
di un prodotto, etc.
Stakeholder
Gli stakeholder sono tutte le persone che in qualche modo sono interessate
al sviluppo di un sistema. Queste persone possono essere ingegneri,
programmatori che stanno sviluppando il sistema o mantenendo sistemi
correlati, manager aziendali, esperti di dominio e rappresentanti sindacali.
Inoltre, possono anche essere gli utenti finali che interagiscono con il
sistema, e tutti gli altri membri di un'organizzazione che potrebbero essere
interessati alla sua installazione.
Obiettivi degli Stakeholder
Gli stakeholder hanno spesso interessi e obiettivi diversi che in genere
dipendono dal ruolo che giocano nel progetto. La figura 2 elenca i principali
ruoli e interessi degli stakeholder.
14

Stakeholder
Interesse nel progetto
Sviluppatori
Foche industo, prevenzione del eroi,
Venditori
Citi eil vendita elevate, maggiore soddisfazione
Responsabili del progetto Riduzione del budget, rispetto del programma
Investitori
Clienti e utenti
Tame to market pi breve, Tus di lavore pia
Flusso di lavoro più semplice, buona usabilità
Figura 2. Stakeholder e loro interessi.
Tipi di sistema software
Esistono diversi tipi di sistemi software. Non esiste un insieme universale
di tecniche software applicabili a tutti questi sistemi. I metodi e gli
strumenti di ingegneria del software utilizzati dipendono da: il tipo di
applicazione sviluppata, i requisiti del cliente e il background del team di
sviluppo.
Esistono diversi tipi sistemi software.
I sistemi autonomi sono sistemi di controllo autonomo che hanno
l'obiettivo di adattarsi agli ambienti in evoluzione.
I sistemi interattivi si basano sulle transazioni e sono dei sistemi di
elaborazione delle informazioni che effettuano la raccolta, la modifica e il
recupero di tutti i dati delle transazioni.
I sistemi di controllo integrati (embedded control systems) sono sistema
hardware che incorporato al loro interno, un microcontrollore che può
essere utilizzato per servire qualsiasi tipo particolare di operazione. Il
sistema integrato può essere indipendente o risiedere in un altro sistema
di grandi dimensioni.
15

I sistemi di elaborazione batch sono sistemi per eseguire elevati volumi di
job sui dati di tipo ripetitivo. Un sistema batch consente di elaborare i dati
quando sono disponibili risorse di elaborazione sufficienti e con
un'interazione minima o nulla da parte dell'utente.
I sistemi di intrattenimento sono solitamente composto da componenti
elettronici che gestiscono audio e video, videogiochi, computer, etc.
I sistemi per la modellazione e simulazione sono utilizzati per l'analisi di una
vasta gamma di sistemi e processi sia naturali che industriali o anche
sociologici. Per esempio, la simulazione del traffico in una rete viaria è di
utilità fondamentale nella progettazione urbanistica e nella gestione del
territorio.
I sistemi di raccolta dati (DCS) sono sistemi che aggregano e valutano gli
insiemi di informazioni in modo coerente ed efficiente. I moderni sistemi
di raccolta dati si basano su una tecnologia avanzata per acquisire enormi
quantità di dati, analizzarli e analizzarli correttamente. Questo fa parte di
ciò che sta dietro la corsa a "sfruttare la potenza dei big data" nei sofisticati
sistemi di rete di oggi.
I sistemi di sistemi (SoS) si basano su diversi sistemi indipendenti che
interagiscono tra di loro per realizzare dei sistemi di maggiore grandezza e
complessità ampio e complesso.
16

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
Dispensa -L2-Attività software di base
Prof. Agostino Poggi
A.A. 2024/2025

Proprietà del Buon Software
Un buon software dovrebbe avere delle qualità che ne evidenziano la
bontà del software sviluppato. In particolare, si dice che un buon software
deve essere robusto, ben documentato, leggibile e consistente.
Inoltre, dovrebbe utilizzare termini del dominio applicativo, dovrebbe
mantenere vicini commenti e relativo codice e, infine, dovrebbe essere
scritto in inglese e utilizzare uno specifico stile.
Gli elementi principali dello stile di codifica sono: l'Indentazione, l'uso degli
spazi vuoti, l'uso delle convenzioni sui nomi, l'uso di tool che individuano
gli errori di stile. Uno strumento molto utilizzato per controllare la
correttezza
dello
stile
usato
è Checkstyle
(https://checkstyle.sourceforge.io/
Legge sugli Standard di Ambler
La legge sugli Standard di Ambler afferma che se uno standard è
comunemente accettato, più facile sarà per i membri del team comunicare
è scrivere il codice in un buon stile. Inoltre, si dice che si può Inventare uno
standard quando necessario, ma non si dovrebbe perdere tempo a creare
qualcosa che potrebbe non essere utilizzare in seguito. Infatti, per gran
parte dei linguaggi di programmazione sono disponibili e consigliati degli
standard di codifica.

Livelli della Qualità degli Stili
Industry
standards
Organizational
standards
Project
standards
No standards
Diffusione dell'Uso degli Stili
10%
3%
Worse
30%
18%
13%
19%
8%
Source: Dr. Dobb's Joumal'» State of the IT Union Suney, July 2009
www.ambysoft.com/wurveys/stateOfTUnior300007.Mml
Copyright 2009 Scott W. Ambler
• No: Not
considered
• No: Hope to do so
• Probably
• Yes: Developer-
level conventions
• Yes: Project-level
conventions
• Yes: Enterprise-
level conventions
• Don't Know/Other
Convenzioni di Codifica dei Nomi
L'uso di parole appropriate e facilmente leggibili è importante per poter
comprendere il codice e quindi per modificarlo ed estenderlo. A questo
4

proposito si dice che in un nome si
dovrebbero combinare le lettere
maiuscole e minuscole per rendere più leggibili i nomi, bosognerebbe usare
parole appropriate e, in particolare, la terminologia applicabile al dominio
del sistema da realizzare e, infine, si dice di evitare nomi lunghi, con
caratteri speciali o di un unico carattere.
Gestione degli Errori
Prevenzione degli errori (prima che il sistema venga rilasciato). Utilizzare
una buona metodologia di programmazione per ridurre la complessità.
Utilizzare il controllo della versione per evitare sistemi incoerenti.
Rilevamento degli errori (mentre il sistema è in esecuzione). Monitoraggio
del sistema per poter fornire informazioni sul suo stato. Test: creare
fallimenti in modo pianificato. Ripristino degli errori (dopo che il sistema è
stato rilasciato). Correzione degli errori (prima o dopo che il sistema è stato
rilasciato). Debug: inizia con un errore non pianificato
Distribuzione Statistica degli Errori
La distribuzione statistica degli errori in un sistema software è del 60% nella
progettazione e il 40% nell'implementazione. Il 66% degli errori di
progettazione non viene scoperto finché il software non diventa operativo.
Vengono commessi 30-85 errori per 1000 righe di codice sorgente. Il
software testato in modo dettagliato contiene 0,5-3 errori per 1000 righe
di codice sorgente. Più tardi viene scoperto un errore, più il costo di
correzione aumenta
Fonti degli Errori
Le principali fonti di errori sono: la cattiva progettazione, l'Isolamento
insufficiente (i.e., un
modulo o un
oggetto
ha
troppe
interazioni/dipendenze con altri moduli o oggetti), gli errori di battitura, i
valori sbagliati per dati di input e, infine, l'accesso a un elemento sbagliato
di una collezione di dati.

Difficoltà nel Riconoscere gli Errori
Se un
errore è
abbastanza grave da causare la chiusura anomala del
programma o la generazione di un'eccezione, l'esistenza di un bug è
evidente. Se l'errore è molto meno grave e causa solo qualche risultata
errato, diventa molto più difficile rilevare l'esistenza di un bug. Cioè
particolarmente vero se è difficile o impossibile verificare i risultati
aspettato dal programma.
Passi per Correggere un Errore
Per correggere un bug, come prima cosa è necessario riconoscere che
esiste il bug, quindi: bisogna isolare la fonte del bug (identificando il codice
coinvolto), identificare la causa del bug, determinare il tipo di
correzione d'applicare al bug e, infine, applicare la correzione e testare
il codice in modo da poter considerare risolto il problema.
Uso di Istruzioni di Stampa
In certe situazioni diventa difficile identificare dove sia l'errore. Una tecnica
spesso usata è quella di introdurre delle operazioni di stampa per riuscire
a capire la sequenza di esecuzione del programma e i risultati delle
operazioni effettuate. In genere le stampe inserire riguardano: i metodi che
sono stati chiamati nel programma, L'ordine in cui sono stati chiamati, i
valori dei parametri utilizzati, i valori delle variabili locali e dei campi nei
punti critici del codice e, nel caso in cui il programma coinvolge lo scambio
tra parti del sistema software, la stampa dei messaggi che sono stati
scambiati con altri processi. Ovviamente, individuato e corretto l'errore, si
dovranno rimuovere il codice di stampa dal programma.
Strumenti a Supporto della Correzione di Errori
Gli strumenti principali che supportano la correzione degli errori sono: il
debugger, i compilatori, i comparatori di codice e gli strumenti di analisi
statica.

Tecniche Principali di Analisi Statica
L'analisi statica è il processo di valutazione di un sistema o di un suo
componente basato sulla sua forma, sulla sua struttura, sul suo contenuto
• sulla documentazione di riferimento. Questa
attività si basa
principalmente sull'uso di un compilatore, sulla lettura del codice, la
trasformazione del codice in un grafo e su
"l'esecuzione statica"
dell'evoluzione del valore delle variabili durante l'analisi del codice.
In particolare, i compilatori eseguono una prima analisi che è in grado do
riconoscere alcune anomalie, ad esempio, gli identificatori non dichiarati,
incoerenza tra tipi di dati coinvolti in una istruzione e il codice non
raggiungibile dal flusso di controllo. La lettura del codice da parte del
programmatore stesso è un'attività che può portare alla luce nuovi difetti,
quali ad esempio, i loop infiniti, inefficienza degli algoritmi e la cattiva
strutturazione del codice. In genere quest'attività viene effettuata da un
gruppo di persone tra cui solitamente almeno uno dei programmatori, e
successivamente discussa e approfondita, viene anche chiamata ispezione
o revisione.
L'analisi del flusso di controllo è invece una tecnica con cui viene data una
rappresentazione del codice in un grafo, dove i nodi denotano istruzioni o
predicati, mentre gli archi il passaggio del flusso di controllo. L'analisi del
grafo può evidenziare l'esistenza di eventuali anomalie quali codice
irraggiungibile e la cattiva strutturazione. Infine, "l'esecuzione statica"
dell'evoluzione del valore delle variabili si basa sull'esecuzione di un
programma in modo statico, ovvero "esegue" le operazioni sulle variabili
del programma. In particolare una variabile può essere definita, usata e
annullata (cancella l'effetto di una precedente definizione della stessa
variabile) e una corretta sequenza di operazioni prevede che una
definizione di una variabile sia sempre seguita da un suo uso.

Testing
È il processo di esecuzione di un programma che ha lo scopo di dimostrare
che un programma fa quello che intende fare e di scoprire i difetti del
programma prima che venga utilizzato. Si basa sull'esecuzione di un
programma o parti di un programma e per individuare gli errori si
controllano i risultati aspettati dalla esecuzione.
Le principali attività del testing sono: scrivere le condizioni dei test,
eseguire i test del sistema e fornire feedback per migliorare il software. Un
test esaustivo è impossibile e quindi si può dimostrare la presenza di bug
ma mai la loro assenza e si è dimostrato che i test statistici non funzionano.
È necessario un modo sistematico di procedere durante i test e solo i test
approfonditi hanno una buona probabilità di realizzare programmi esenti
da difetti.

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
Dispensa -L3 - Processi software
Prof. Agostino Poggi
A.A. 2024/2025

Processi e modelli di processi software
Un processo è un insieme strutturato di attività necessarie per sviluppare
un
sistema
software. Un modello
di processo
software
una
rappresentazione astratta di un processo. I processi possono essere guidati
dai piani (plan-driven) o agili, Le implementazione dei processi software
possono avere delle differenze. I processi software hanno delle attività
condivise.
I processi guidati dal piano sono processi in cui tutte le attività del processo
sono pianificate in anticipo e i progressi vengono misurati rispetto a questo
piano. È
un
approccio specifico più formale alla
creazione
di
un'applicazione
Questi piani si basano su un approccio specifico più formale alla creazione
di un'applicazione e utilizzano metodologie che partono dalla definizione
dell'architettura di sistema e incorporano: la ripetibilità e prevedibilità, un
processo incrementale ben definito, della documentazione estesa, dei
piani dettagliati, il monitoraggio e controllo dei processi, la gestione del
rischio, e infine, la verifica e convalida del software sviluppato.
Nei processi agili, la pianificazione è incrementale ed è più semplice
modificare il processo per riflettere le mutevoli esigenze dei clienti. In
pratica, la maggior parte dei processi pratici include elementi di approcci
sia guidati dal piano che agili. In particolare, i processi agili utilizzano un
approccio allo sviluppo del software basato sulla distribuzione e continua
di software efficienti creati in modo rapido e iterativo, che consiste nel
rilasciare rapidamente modifiche al software in piccole porzioni
con
l'obiettivo di migliorare la soddisfazione dei clienti. Inoltre, lo sviluppo si
basa sul lavoro di gruppo e si usa un approccio flessibile che gli permette
di concentrarsi sul miglioramento continuo della qualità del software.
Infine, i team sono costituiti da pochi sviluppatori ciascuno, si organizzano
in autonomia e collaborano direttamente con i rappresentanti aziendali
tramite incontri periodici durante l'intero ciclo di vita dello sviluppo del

software. Infine, due sue caratteristiche principali sono: l'uso di un
approccio più leggero alla stesura della documentazione software e la
possibilità di applicare delle modifiche in qualsiasi fase del ciclo di vita del
software.
I principali modelli di sviluppo software sono: il modello a cascata, lo
sviluppo incrementale, l'integrazione e configurazione.
Il modello a cascata è un modello basato sul piano. Usa fasi separate e
distinte di specifica e sviluppo.
Lo sviluppo incrementale intercala specifica, sviluppo e validazione. Può
essere guidato dal piano o agile.
L'integrazione e configurazione realizza un sistema assemblando dei
componenti configurabili esistenti. Può essere guidato dal piano o agile.
In pratica, la maggior parte dei sistemi di grandi dimensioni viene
sviluppata utilizzando un processo che incorpora elementi di questi tre
modelli e, in certe situazioni, si usa un approccio misto (detto anche ibrido)
che combina le tecniche e metodologie dei modelli di sviluppo software
introdotti precedentemente.
Studio di fattibilità
È uno studio preliminare sulle implicazioni che il sistema avrà una volta
costruito e sulla sua convenienza. Risultato di questa fase sarà una
raccomandazione sul continuare o meno lo sviluppo. alcune domande a cui
tipicamente uno studio di fattibilità dovrà rispondere sono:
• Il sistema contribuisce al raggiungimento degli obiettivi
dell'organizzazione a cui è rivolto?
• Quale è il suo impatto?
• Può il sistema essere implementato con le tecnologie correnti e con
costi e tempi "prevedibili"?
• Può il sistema essere integrato con dei sistemi preesistenti?

Modello a cascata
Il modello a cascata (waterfall model ) è probabilmente il modello più
conosciuto e forse anche il più utilizzato per gestire il ciclo di vita del
software. Prevede l'esecuzione lineare di una precisa sequenza di fasi,
ciascuna delle quali genera un output utilizzato come input della fase
successiva. Questa sequenza di fasi comprende:
• Studio di fattibilità (spesso realizzato separatamente)
• Analisi dei requisiti
• Definizione dei requisiti
• Specifica dei requisiti
@clintot
del requisiti
Progettazione del
Sistema e del software
Programmazione
Integrazione
testing del sistema
Funzionamento
e manutenzione
Problemi del modello a cascata
Lo svantaggio principale del modello a cascata è la difficoltà di accogliere il
cambiamento una volta avviato il processo. Infatti, in linea di principio, una
fase deve essere completata prima di passare alla fase successiva.
La suddivisione del progetto in fasi distinte rende difficile rispondere alle
mutevoli esigenze dei clienti. Pertanto, questo modello è appropriato solo
quando i requisiti sono ben compresi e le modifiche saranno piuttosto
limitate durante il processo di progettazione. Pochi sistemi aziendali hanno
requisiti stabili.
Il modello a cascata viene utilizzato principalmente per sistemi di grandi
dimensioni sviluppati in diversi siti, la natura pianificata del modello a
cascata aiuta a coordinare il lavoro. In particolare, i vantaggi di questo

modello sono: la documentazione e le specifiche sono ben dettagliate e la
manutenzione è facile da eseguire. Tuttavia, il cliente coinvolto solo
all'inizio (quindi non ha modo di intervenire sulle attività successive),
l'esecuzione delle fasi è sequenziale (se si identifica un errore in una fase,
questo può comportare la necessità di operare su le fasi precedenti).
Inoltre, i risultati delle fasi vengono congelati prima di procedere alle fasi
successive. I modello, di conseguenza, assume che i requisiti e le specifiche
di progetto possano essere congelati nelle prime fasi di sviluppo, quando
le conoscenze dell'area applicativa e l'esperienza sono ancora preliminari
e soggette a cambiamento.
Uno dei problemi principali è che questo modello è strutturato in modo
tale da non prevedere alcun ritorno alla fase precedente. Quindi, qualsiasi
errore commesso in una qualsiasi delle fasi di sviluppo, comporta un
aumento dei costi, del tempo del progetto e dell'impegno del team. Per
questo motivo, il modello a cascata non dovrebbe essere utilizzato in un
ambiente dinamico che richiede un approccio iterativo.
Applicabilità del Modello a Cascata
L'utilizzo o meno del modello a cascate dipende da alcune condizioni: i
requisiti del sistema da sviluppare sono ben compresi e si prevede che le
modifiche saranno limitate. Inoltre, il modello a cascata viene utilizzato
principalmente per sistemi di grandi dimensioni sviluppati in diversi siti.
Infatti, la documentazione realizzata nelle diverse fasi di sviluppo la aiuta
ad eseguire e coordinare il lavoro tra i diversi gruppi di lavoro
Modello a Cascata - Pro e Contro
• La documentazione è dettaglia
© La manutenzione è facile da eseguire
© Le Specifiche sono ben dettagliate
© Il cliente è coinvolto solo nella prima fase del progetto
• L'esecuzione delle fasi è sequenziale e ogni fase può iniziare solo al
termine della precedente
a I prodotti del sistema diventano disponibile molto tardi
6

Modello a cascata con feedback
Il modello a cascata tradizionale è difficile da usare perché non offre un
meccanismo per la correzione degli errori. Queste difficoltà sono superabili
utilizzando un modello a cascata con feedback (detto anche modello a
cascata iterativa) perché è introdotto un percorso di feedback da una fase
alla fase precedente che consente di correggere gli errori commessi.
Ovviamente queste correzioni introduco dei cambiamenti che si riflettono
nelle fasi successive.
Definizione
del requisiti
Progettazione del
Sistema e del software
Programmazione
e test di unita
Integrazione e
testing del sistema
Funzionamento
e manutenzione
Waterfall V Model
Il modello a cascata V è un'estensione del modello a cascata che si basa
sull'associazione di una fase di testing per ogni corrispondente fase di
sviluppo. Questo tipo di configurazione permette di associare ad ogni
singola fase del ciclo di sviluppo una fase di test. La differenza
fondamentale tra il modello a cascata e il modello a cascata V è che nel
modello a cascata il test del software viene eseguito dopo il
completamento della fase di sviluppo mentre nel modello a cascata V, ogni
fase del ciclo di sviluppo ha una fase di test direttamente associata.

Requirements
specification
System
specification
System
design
Detailed
design
Acceptance
test plan
System
integration
test plan
Sub-syster
integration
test plan
Module and
unit code
ande
Service
Acceptance
System
integration test
Sub-system
integration test
Sviluppo Incrementale
Invece di fornire il sistema come un'unica consegna, lo sviluppo e la
consegna sono suddivisi in incrementi. Ciascun incremento fornisce parte
delle funzionalità. Ad ogni requisito viene assegnata una priorità e i
requisiti con la priorità più alta vengono inclusi negli incrementi iniziali. Una
volta avviato lo sviluppo di un incremento, i relativi requisiti vengono
congelati, ma i requisiti per gli incrementi successivi possono continuare ad
evolversi. Il software del sistema non viene consegnato alla fine dello
sviluppo. Il software di ogni incremento viene inviato ai clienti e agli utenti
del sistema in sviluppo. Inoltre, un rappresentante del cliente può:
decidere l'ordine in cui sviluppare gli incrementi e approvare o non
approvare l'implementazione di alcuni incrementi.

Requirements
Outline
Description
Design
Initial
Version
Intermediate
Versions
Implementation
Final Version
Sviluppo e consegna incrementale - Pro e Contro
Il valore per il cliente viene fornito con ogni incremento. Il costo per
realizzare delle modifiche è limitato. Si riduce il rischio di fallimento
complessivo del progetto e del tempo di sviluppo. I servizi ad alta priorità
ricevono il maggior numero di test. Tuttavia, c'è una mancanza di visibilità
del processo e i sistemi sono spesso mal strutturati e le strutture comuni
(e.g., i moduli, i componenti e i connettori) sono difficili da identificare.
Applicabilità dello sviluppo incrementale
Lo sviluppo Incrementale si può utilizzare quando i requisiti del sistema
sono chiaramente definiti e compresi, quando i sistemi sono di piccole o
medie dimensioni, quando si vogliono solo sviluppare parti di sistemi di
grandi dimensioni (ad esempio, l'interfaccia utente), quando si vogliono
sviluppare sistemi che si pensa debbano avere una breve durata, e quando
il cliente richiede un rapido rilascio del prodotto.

Definire
i requisiti
Assegnare i
requisiti agli
incrementi
Progettare
l'architettura
del sistema
Sviluppare un
incremento del
sistema
Il sistema
non e
completato?
Validare
l'incremento
Integrare
l'incremento
Validare il
sistema
Rilasciare
l'incremento
Il sistema è
completato?
Sistema
finale
Diagramma - Sviluppo Incrementale
Requirements
Initial
Version
Outline
Description
Design
Intermediate
Versions
Implementation
Final Version
Integrazione e Configurazione
Oggigiorno, Il riutilizzo del software è diventato un approccio standard per
la costruzione di molti tipi di sistemi software. L'integrazione e
configurazione si basa sul riutilizzo del software in cui i sistemi sono
integrati da componenti, librerie software e sistemi software esistenti
(detti COTS - Commercial-off-the-shelf systems). In questo approccio, gli
elementi riutilizzati possono essere configurati e adattati nel loro
comportamento e funzionalità per soddisfare le esigenze dell'utente.
10

Diagramma - Integrazione e Configurazione
Individuazione
del software
Specifica dei
requisiti
Raffinamento
dei requisiti
Valutazione
del software
Configurazione
del sistema
Adattamento
dei componenti
Integrazione
del sistema
Sviluppo di
componenti
Integrazione e Configurazione - Pro e Contro
L'uso dell'Integrazione e configurazione riduce I costi e I rischi di sviluppo
e permette di velocizzare il rilascio e l'installazione dei sistemi.
Tuttavia, sono inevitabili dei compromessi sui requisiti che si vorrebbero
implementate (i.e., realizzare delle nuove implementazioni dei componenti
può essere molto costoso e quindi si può decidere di riutilizzare dei
componenti che soddisfano in gran parte i requisiti, ma che potrebbero
avere una migliore implementazione.
Un grosso problema sorge quando si riutilizzano componente sviluppati da
terze parti. Infatti, questi componenti possono subire modifiche ed
aggiornamenti che sono quasi sempre solo sotto il controllo delle terze
parti.
11

Distribuzione dei Costi di Sviluppo
A seconda del tipo di sviluppo che si vuole effettuare, si hanno differenti
costi per le diverse attività. La cosa più importante, che si può notare, è che
se abbiamo un sistema che sta avendo una lunga attività di servizio e ne
misuriamo la differenza tra il costo di sviluppo del sistema e il costo della
sua evoluzione (manutenzione e modifica, correzione e aggiunta di
funzionalità) si misurerà un costo di sviluppo molto minore del costo di
evoluzione. Inoltre, la qualità del sistema iniziale ha un'influenza molto
importante sui costi della sua evoluzione.
Waterfall model
25|
50
75
100
Specification
Design
Development
Integration and testing
Iterative development
25
50
75
100
Specification
Iterative development
System testing
Integration and configuration
25
50
100
Specification
Development
75
Integration and testing
Development and evolution costs for long-lifetime systems
25
50
75
100
System development
System evolution
12

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
Dispensa -L4- Ingegneria dei requisiti
Prof. Agostino Poggi
A.A. 2024/2025

Definizione di Ingegneria dei Requisiti
L'ingegneria dei requisiti è un processo di definizione dei servizi che un
cliente richiede da un sistema e i vincoli in base ai quali il sistema opera e
si sviluppa. I requisiti di sistema sono le descrizioni dei servizi e dei vincoli
generati durante il processo di ingegneria dei requisiti.
Definizione e astrazione dei requisiti
Un requisito può avere diverse definizioni che possono variare
da una
dichiarazione astratta di alto livello di un servizio a un vincolo di sistema a
una dettagliata specifica funzionale e/o matematica.
In particolare, i requisiti possono essere la base per un'offerta per un
contratto che in genere non ha una definizione dettagliata e completa, e
quindi può essere aperta a diverse interpretazioni; o può essere la base
per il contratto stesso e quindi deve essere definito in dettaglio.
Quando un'azienda o una persona o un gruppo di persone desiderano fare
un contratto per un progetto, per poter avere più alternative per la
realizzazione del loro progetto, devono definire le proprie esigenze in
modo sufficientemente astratto per garantire che non ci sia un'unica
soluzione predefinita.
Quindi,
i requisiti devono essere scritti in modo che più appaltatori
possano presentare un'offerta per l'appalto, offrendo modi diversi per
soddisfare le esigenze dell'organizzazione o del cliente.
Una volta che un contratto è stato aggiudicato, l'appaltatore deve scrivere
una definizione di sistema in modo più dettagliato per garantire che il
cliente capisca e possa convalidare ciò che farà il software
Requisiti dell'Utente e del Sistema
I requisiti vengono divisi in due categorie: i requisiti dell'utente e i requisiti
del sistema. I requisiti dell'utente rispecchiano il punto di vista del
"cliente" (sono scritti per e con il cliente), ed essendo rivolti a personale
non esperto e disinteressato ai dettagli implementativi, determinano solo

il comportamento esterno del sistema mediante una descrizione chiare dei
servizi che esso dovrebbe fornire ed i vincoli sotto cuoi dovrà operare.
Per questo motivo, spesso l'utente non fornisce una descrizione chiara e
dettagliata. Ad esempio, la sua descrizione iniziale potrebbe essere: "il
sistema genererà rapporti di gestione mensili che mostrano il costo dei
farmaci prescritti da ciascuna clinica durante quel mese". Invece tutti gli
aspetti tecnici prendono forma nei requisiti di sistema, i quali sono
specificati mediante la stesura di un "documento" strutturato che descrive
in modo più dettagliato le funzioni, i servizi e i vincoli operativi del sistema
software.
Quindi possiamo pensare a essi come una "versione espansa" dei requisiti
utente e dovrebbero descrivere semplicemente, utilizzando notazioni più
dettagliate rispetto a quelle adoperate per i requisiti utente, il
comportamento esterno del sistema, senza specificare "come" il sistema
dovrebbe essere progettato o implementato.
Ad esempio, questa descrizione "espansa" potrebbe specificare con grande
precisione i passi che soddisfano l'obiettivo dell'utente. Questi passi
potrebbero essere:
1.1 L'ultimo giorno lavorativo di ogni mese deve essere generato un
riepilogo dei farmaci prescritti, del loro costo e delle cliniche di prescrizione
1.2 ll sistema genererà il report per la stampa dopo le ore 17.30 dell'ultimo
giorno lavorativo del mese
1.3 Deve essere creato un rapporto per ogni clinica e deve elencare i nomi
dei singoli farmaci, il numero totale di prescrizioni, il numero di dosi
prescritte e il costo totale dei farmaci prescritti
1.4 Se i farmaci sono disponibili in diverse unità di dose (ad es. 10 mg, 20
mg, ecc.), devono essere creati report separati per ciascuna unità di dose

Imprecisione dei Requisiti
I problemi sorgono quando i requisiti funzionali non sono definiti con
precisione. Infatti, dei requisiti ambigui possono essere interpretati in modi
diversi da sviluppatori e utenti.
Ad esempio, l'utente ha detto allo sviluppatore che dovrebbe cercare il
nome di un paziente in tutti gli appuntamenti in tutte le cliniche e lo
sviluppatore potrebbe pensare che l'obiettivo del cliente possa essere
cercare il nome di un paziente in una singola clinica, la clinica è scelta
dall'utente che poi fa la ricerca.
Consistenza e Complessità dei Requisiti
In linea di principio, i requisiti dovrebbero essere completi e coerenti. In
particolare, si possono dire completi se includono le descrizioni di tutte le
strutture richieste e coerenti se non ci sono conflitti o contraddizioni nelle
descrizioni delle funzionalità del sistema. In pratica, a causa della
complessità dei sistema e dell'ambiente, è molto difficile se non
impossibile produrre un documento dei requisiti completo e coerente.
Tipi di Requisiti
Esistono tre tipi di requisiti; i requisiti funzionali, i requisiti non funzionali e
i requisiti di dominio.
I requisiti Funzionali descrivono le funzionalità e servizi che il sistema
dovrebbe fornire, come il sistema dovrebbe reagire a particolari input e
come il sistema dovrebbe comportarsi in situazioni particolari è può
indicare ciò che il sistema non dovrebbe fare. In particolare, deve descrive:
I dati da inserire nel sistema, le operazioni da eseguire, i flussi di lavoro che
il sistema dovrà eseguire sistema, i report di sistema e altri output che
dovranno essere generati, gli utenti che possono inserire i dati nel sistema,
i modi in cui il sistema dovrebbe reagire a particolari input e come
dovrebbe comportarsi in situazioni particolari. Ovviamente, il
comportamento dipenderà molto dal tipo di software, dagli utenti previsti
e dal tipo di sistema in cui viene utilizzato il software.

I Requisiti non funzionali definiscono proprietà e vincoli del sistema, ad
esempio affidabilità, tempo di risposta e requisiti di archiviazione. Ad
esempio, i requisiti non funzionali di processo possono anche essere
specificati imponendo un particolare IDE, linguaggio di programmazione o
metodo di sviluppo. I requisiti non funzionali possono essere più critici dei
requisiti funzionali perché se non sono soddisfatti, il sistema potrebbe
essere inutile. Inoltre, i requisiti non funzionali possono influenzare
l'architettura complessiva di un sistema piuttosto che i singoli componenti.
Ad esempio, per garantire che i requisiti di prestazione siano soddisfatti,
potrebbe essere necessario organizzare il sistema per ridurre al minimo le
comunicazioni tra i componenti.
Un singolo requisito non funzionale, come un requisito di sicurezza, può
generare una serie di requisiti funzionali correlati che definiscono i servizi
di sistema richiesti.
Un requisito non funzionale può anche generare requisiti che limitano i
requisiti esistenti.
Classificazione dei Requisiti non Funzionali
I requisiti non funzionali sono divisi tre categorie: i requisiti del prodotto, i
requisiti organizzativi e i requisiti esterni.
I requisiti del prodotto specificano che il prodotto consegnato deve
comportarsi in un modo particolare, ad esempio velocità di esecuzione,
affidabilità, etc. Un esempio di requisito del prodotto può essere: "Il
sistema deve essere disponibile per tutte le cliniche durante il normale
orario di lavoro (lun-ven, 08:30-17:30). I tempi di inattività durante il
normale orario di lavoro non devono superare i cinque secondi al giorno".
I requisiti organizzativi sono dei requisiti creati come conseguenza delle
politiche e delle procedure organizzative, ad esempio standard di processo
utilizzati, requisiti di implementazione, etc. Un esempio di requisito
organizzativo può essere: "Gli utenti del sistema devono autenticarsi
utilizzando la propria carta di riconoscimento dell'azienda sanitaria".

I requisiti esterni derivano da fattori esterni al sistema e al suo processo di
sviluppo, ad esempio requisiti di interoperabilità, requisiti legislativi, etc.
Un esempio di requisito esterno può essere: "Il sistema deve implementare
le disposizioni sulla privacy del paziente come indicato dall'allegato
«HStan-03-2006-priv»".
I requisiti di dominio provengono dal dominio applicativo del sistema e
riflettono le caratteristiche di tale dominio e possono avere dei funzionali
e non funzionali.
Questi requisiti sono spesso difficili da comprendere. Infatti, si dice che è
difficile per un non specialista comprendere le implicazioni della loro
introduzione e come interagiscono con altri requisiti.
La cosa importante da capire è che se, i requisiti di dominio non sono stati
integrati correttamente, allora il sistema potrebbe essere non utilizzabile,
Tipologie dei Requisiti non Funzionali
Non functional
requirements
Product
requirements
Organisational
requirements
External
requirements
Efficiency
requirements
Reliability
reputerete
Portability
requirements
Interoperability
requirements
Ethical
requirements
requirements
Delivery
requirements
Implementation
requirements
Standards
doVererent
requirements
requirements
Privacy
requirements
Safety
requirements

Obiettivi e Requisiti non Funzionali Verificabili
Obiettivo e requisiti non funzionali verificabili sono due termini che
indicano due livelli differenti di descrizione di un requisito non funzionale.
In particolare, la frase "il sistema dovrebbe essere facile da usare da parte
del personale medico e dovrebbe essere organizzato in modo tale da
ridurre al minimo gli errori dell'utente" è un "obiettivo" perché è una
descrizione poco chiara e dettagliata di un requisito non funzionale.
Le due frasi "il personale medico sarà in grado di utilizzare tutte le funzioni
del sistema dopo quattro ore di formazione" e "dopo questa formazione, il
numero medio di errori commessi da utenti esperti non deve superare i
due per ora di utilizzo del sistema" definisco un requisito non funzionale
verificabile visto che indicano una descrizione chiara e dettagliata.

Esempi di Metriche per i Requisiti non Funzionali
Proprietà
Velocità
Misure
Transazioni elaborate/secondo
Tempo di risposta utente/evento
Tempo di aggiornamento dello schermo
Dimensioni
Gbyte
Numero di chip ROM
Facilità di uso Tempo di allenamento
Numero di frame di aiuto
Affidabilità
Tempo medio al fallimento
Probabilità di indisponibilità
Tasso di occorrenza del guasto Disponibilità
Robustezza
Tempo necessario per riavviare dopo il fallimento
Percentuale di eventi che causano guasti
Probabilità di danneggiamento dei dati in caso di errore
Portabilità
Percentuale di istruzioni dipendenti dall'implementazione
Numero di parti/componenti da "studiare"
Processi dell'Ingegneria dei Requisiti
L'ingegneria dei requisiti è un'attività iterativa in cui questi processi sono
interlacciati.
I processi utilizzati nell'ingegneria dei requisiti dipendono dal dominio,
dalle persone e dalle organizzazioni coinvolte nello sviluppo del sistema. In
particolare, esistono quattro attività generiche comuni a tutti i processi di
ingegneria dei requisiti.
Queste attività sono: la raccolta (elicitazione) dei requisiti, l'analisi dei
requisiti, la convalida dei requisiti e la gestione dei requisiti.

Processo Base dell'Ingegneria dei Requisiti
Feasibility
Study
Requirements
Elicitation and
Analysis|
Requirements
Specification
Feasibility
Report
System Models
User and System
Requirements
Processo dell'Ingegneria dei Requisiti a Spirale
System requirements
specification and modeline
User requirements
specification
Business requirements
specification
requirements
Feasibility
study
User requirements
elicitation
Requirements
Elicitation
Prototyping
System requirements
document
Requirements
Validation
Requirements
Document
Requirements
Specification
Requirements
Validation
10

Raccolta dei Requisiti e relativi problemi
E il processo di raccolta delle informazioni sui sistemi esistenti e che si
vogliono sviluppare ed è basato sul lavoro di utenti finali, manager,
ingegneri, esperti di dominio, sindacati, etc. Tramite le informazioni
acquisite si possono identificare i requisiti dell'utente e del sistema.
Coinvolge il personale tecnico che lavora con i clienti per scoprire il dominio
dell'applicazione, i servizi che il sistema dovrebbe fornire e i vincoli
operativi del sistema.
La raccolta delle informazioni può essere problematica per vari motivi. Le
parti interessate non sanno cosa vogliono veramente, esprimono i requisiti
nei propri termini e possono avere requisiti contrastanti. Inoltre, dei fattori
organizzativi e politici possono influenzare i requisiti di sistema, i requisiti
possono cambiare durante il processo di analisi e potrebbero emergere
nuove parti interessate e/o l'ambiente aziendale potrebbe cambiare.
Tuttavia, le attività di questo processo permettono di ottenere dei buoni
risultati: si possono scoprire le esigenze degli stakeholter attraverso la loro
interazioni, si riesce ad acquisire buone informazioni sui requisiti di
dominio.
Inoltre, si riesce a dare una buona organizzazione ai requisiti tramite alcune
semplici operazioni: i requisiti vengono raggruppati in cluster coerenti,
vengono assegnate le priorità ai requisiti e gestisce la risoluzione dei
conflitti di requisiti e vengono documentati i requisiti .
Tecniche di Raccolta dei Requisiti
Le tecniche di raccolta più utilizzare sono: le interviste, i questionari, i brain
storming e l'osservazione dell'utente (etnografia).
Le interviste consistono in colloqui formali o informali basate su interviste
chiuse (le domande sono uguali per tutti gli intervistati) e Interviste aperte
(le domande sono generate in base all'interazione con l'intervistato). Per
rendere le interviste proficue, è necessario che l'intervistatore riesca a

mostrare
dei comportamenti efficaci che facilitano l'interazione coi gli
intervistati. Per ottenere ciò, si dice che l'intervistatore dovrebbe avere
una mentalità aperta e una grande disponibilità ad ascoltare. Inoltre, se
l'intervistato ha problemi ad interagire, allora l'intervistatore dovrebbe
cercare di aiutarlo e invogliarlo ad esprimere le sue idee e, se possibile,
dargli dei suggerimenti. Spesso, un problema ricorrente è la difficoltà di
comprensione del linguaggio del cliente e della terminologia specifica del
dominio applicativo.
I questionari si basano su quattro attività: si devono scrivere le domande,
queste domande sono testate su un piccolo campione di intervistati, se è
necessario viene aggiornato il questionario e, infine, viene il questionario
vie duplicato e distribuito. L'uso di un questionario permette di avere
velocemente informazioni da molte persone, ma non c'è
nessuna
interazione tra intervistatore e intervistati.
Il brain storming è una tecnica creativa di gruppo per far emergere idee
volte alla risoluzione di problemi e stabilire dei criteri per valutare le idee.
In particolare, questa tecnica parte con l'organizzare una riunione in cui
ogni partecipante propone le sue idee. In genere vengono proposte molte
idee, ma se il numero delle proposte è in genere alto, la qualità delle idee
proposte è basso.
Il punto critico è decidere quali idee accettare e quali no. A questo
proposito sono state utilizzate diverse soluzioni: l'uso di criteri di
accettazione decisi prima della riunione, il filtraggio delle idee, le votazioni
con soglia, con discorsi a favore di idee con strategia di voto, etc.
L' Etnografia si basa sull'osservazioni e l'analisi del modo in cui le persone
lavorano effettivamente.
Questa tecnica richiede interazione con le persone che lavorano per non
alterare il modo in cui queste lavorano.
Quello che si dice è che il lavoro è solitamente più ricco e complesso di
quanto suggerito dai modelli definiti per descrivere il sistema.
12

Inoltre, permettono di individuare fattori sociali e organizzativi importanti
e ii possono individuare dei requisiti attraverso l'osservazione della
collaborazione tra le attività di persone.
L'Etnografia è efficace per comprendere i processi esistenti ma non può
identificare caratteristiche che dovrebbero essere aggiunte a un sistema.
Integrazione dell'Etnografia con la Prototipazione
L'etnografia può essere combinata con lo sviluppo di un prototipo di
sistema. Infatti, con lo sviluppo del prototipo sono necessari meno cicli di
perfezionamento del prototipo. Inoltre, la prototipazione focalizza
Analisi
etnografica
Riunione
informativa
Etnografia
Valutazione
prototipo
Sviluppo
sistema
Prototipazione
sistema
l'etnografia identificando problemi e domande che possono poi essere
discussi con l'etnografo. Quindi lo stesso etnografo dovrebbe cercare le
risposte a queste domande durante la fase successiva dello studio del
sistema. Nel diagramma qui sopra la parola sistema indica in realtà il
prototipo.
Specifica dei Requisiti
Le specifica dei requisiti coinvolgono due tipi di requisiti: i requisiti degli
utenti e i requisiti di sistema.
Questa specifica è in genere scritta in linguaggio naturale e può essere
integrati con diagrammi e tabelle. Inoltre, possono usare notazioni basate
su moduli, grafici o modelli di sistema matematici.
La scrittura del documento della specifica dei requisiti è in linguaggio
naturale, ma la sua preparazione e lettura deve spesso affrontare delle
difficoltà. In genere, diverse frasi e paragrafi del documento sono poco
chiari, leggibilità e precisione non vanno d'accordo. Infatti, si dice che non
si può essere precisi senza rendere difficile la lettura del documento.
13

Spesso nel testo c'è una descrizione confusa dei requisiti e i requisiti
funzionali e non funzionali tendono a essere confusi, e diversi requisiti
possono essere espressi insieme.
Linee Guida per la Descrizione dei Requisiti
Per fornire una buona descrizione dei requisiti si consiglia di: usare o
inventare un formato standard, indicare la priorità del requisito,
evidenziare le parti chiave del requisito, vitare l'uso del gergo informatico
e, per finire, spiegare sempre perché un requisito è necessario.
Strumenti per la Descrizione dei Requisiti
Per descrivere i requisiti si possono utilizzare diversi strumenti: Il linguaggio
naturale, I linguaggi naturale strutturato, le notazione grafiche e le
specifiche matematiche.
Con il linguaggio naturale i requisiti sono definiti utilizzando frasi numerate
in linguaggio naturale e ogni frase dovrebbe esprimere un requisito.
Con il linguaggio naturale strutturato: i requisiti sono definiti in linguaggio
naturale in un modulo o modello standard e ogni campo fornisce
informazioni su un aspetto del requisito.
Con le notazione grafiche: i requisiti sono definiti integrando modelli grafici
e annotazioni testuali e vengono comunemente utilizzati casi d'uso UML,
diagrammi di sequenza e vincoli OCL.
Infine, con le specifiche matematiche: i requisiti sono definiti usando
strumenti matematici come macchine e insiemi a stati finiti.
Queste specifiche possano ridurre l'ambiguità in un documento di requisiti,
ma la maggior parte dei clienti non comprende una specifica formale.
14

Requisiti di una Pompa per Insulina
I requisiti per realizzare una pompa per l'insulina possono essere descritti
dalle frasi seguenti:
1. Il sistema misura la glicemia ed eroga l'insulina, se necessario, ogni
10 minuti
2. Le variazioni della glicemia sono relativamente lente, quindi non è
necessario eseguire misurazioni più frequenti
3. Una misurazione meno frequente potrebbe portare a livelli di
zucchero inutilmente elevati
4. Il sistema eseguirà una routine di autotest ogni minuto con le
condizioni da testare e le azioni necessarie
5. Una routine di autotest può rilevare problemi hardware e software e
avvisare l'utente del fatto che il normale funzionamento potrebbe
essere impossibile
Specifiche Basate sui Moduli
Le specifiche modulari forniscono una definizione della funzione che si
vuole realizzare basata su una serie di elementi: la descrizione degli input
e l'indicazione da dove provengono, la descrizione degli output e dove sono
diretti, le Informazioni necessarie per il calcolo dei valori da utilizzare, la
descrizione dell'azione da intraprendere, le pre e post condizioni e, infine,
gli eventuali effetti collaterali della funzione.
Specifiche Tabulari
Le specifiche tabulari sono utilizzate per integrare il linguaggio naturale.
Queste specifiche sono particolarmente utile quando è necessario definire
una serie di possibili linee d'azione alternative.
Ad esempio, i sistemi della pompa per insulina basano i propri calcoli sulla
velocità di variazione del livello di zucchero nel sangue. La specifica
tabellare introdotta qui sotto spiega come calcolare il fabbisogno di
insulina per diversi scenari.
15

Specifica Tabulare della Dose di Insulina
• Funzione |
• Calcolare la dose di insulina:
livello di zucchero sicuro.
• Descrizione
• Calcola la dose di insulina da
erogare quando l'attuale livello di
zucchero misurato è nella zona
sicura tra 3 e 7 unita.
• Ingressi
• Lettura attuale dello zucchero
(r2); le due letture precedenti
(rO e r1).
• fonte
• Lettura attuale dello zucchero dal
sensore. Altre letture a memoria.
• Uscite
• CompDose: la dose di insulina dal
erogare.
• Destinazione
* Ciclo di controllo principale.
* Azione
• CompDose è zero se il livello di zucchero è stabile
o in diminuzione o se il livello sta aumentando
ma il tasso di aumento sta diminuendo. Se il
livello è in aumento e la velocità di aumento è in
aumento, CompDose viene calcolato dividendo
per 4 la differenza tra il livello di zucchero attuale
e il livello precedente e arrotondando il risultato.
Se il risultato è arrotondato a zero, allora
CompDose è impostato sulla dose minima che
può essere erogata.
• Requisiti
• Due letture precedenti in modo da poter
calcolare il tasso di variazione del livello di
zucchero.
• Precondizione
• Il serbatoio di insulina contiene almeno la dose
singola massima consentita di insulina.
• La post-condizione rO è sostituita da r1, quindi r1
è sostituito da r2.
• Effetti collaterali Nessuno.
Specifica Modulare della Dose di Insulina
Condizioni
Azioni
Livello di zucchero in calo (r2 < r1)
CompDose = 0
Livello di zucchero stabile (12 == r1)|
CompDose = 0
Livello di zucchero in crescita e tasso
di incremento decrescente
((12-51) < (1 -r0))
Livello di zucchero in aumento e
tasso di aumento stabile o in
aumento
((r2 - r1) ≥ (г1 - гО))|
CompDose = 0
CompDose =
16

Documento dei Requisiti del Software
Questo documento è la dichiarazione ufficiale di ciò che è richiesto agli
sviluppatori del sistema.
Il documento non è un documento di progettazione e dovrebbe includere
una definizione dei requisiti utente e una specifica dei requisiti di sistema.
In particolare, dovrebbe stabilire cosa dovrebbe fare il sistema piuttosto
che come dovrebbe farlo.
Le persone che dovrebbero esaminare il documento sono: i clienti, i
manager, gli Ingegneri del sistema e gli Ingegneri dei test del sistema.
Questo documento dovrebbe sempre presentare alcuni elementi
fondamentali. In particolare, una prefazione e un'introduzione, un
glossario, una definizione dei requisiti dell'utente, la descrizione
dell'architetture del sistema, la definizione dei requisiti del sistema, alcuni
modelli del sistema, l'evoluzione prevista per il sistema.
Se necessario, potranno essere aggiunte anche delle appendici, infine,
come ultimo elemento dovrà essere inserito un indice.
Variabilità e problemi dei Documenti dei Requisiti
La stesura dei documenti dei requisiti coinvolge diverse persone (gli
stakeholder) e deve documentare diversi tipi di sistema e diversi tipi di
sviluppo e quindi certi documenti dei requisiti possono essere molto diversi
da altri.
Ad esempio, i sistemi sviluppati in modo incrementale hanno, in genere,
meno dettagli nel documento dei requisiti rispetto ai sistemi sviluppati in
modo plan-driven.
In altri casi, si usano degli standard di scrittura di questi documenti e, tra
questi, lo standard IEEE e sicuramente il più conosciuto.
Tuttavia, questi standard sono In genere applicabili ai requisiti per i grandi
progetti di ingegneria dei sistemi.
17

Verifica dei Requisiti
- La verifica dei requisiti può considerata conclusa se vengono
soddisfatte le seguenti proprietà:
- Validità: Il sistema fornisce le funzioni che meglio supportano le
necessità degli utenti
- Consistenza: non ci sono conflitti tra i requisiti e descrizioni
differenti della stessa funzione
- Completezza: Sono incluse tutte le funzioni richieste dagli utenti
- Realismo: i requisiti possono essere implementati con il budget, le
tecnologie e nel tempo a disposizione
- Verificabilità: il sistema soddisfa i requisiti
- Comprensibilità: Il requisito è stato compreso completamente
- Tracciabilità: l'origine del requisito è espressa chiaramente
- Adattabilità: si possibile cambiare il requisito senza un grande
impatto sugli altri requisiti
- Realismo: I requisiti possono essere implementati con il budget, le
tecnologie e nel tempo a disposizione
Tecniche per la Verifica dei Requisiti
Le tecniche per verificare la correttezza dei requisiti sono principalmente,
la revisioni dei requisiti, l'analisi manuale sistematica dei requisiti, la
prototipazione, l'utilizzo di un modello eseguibile del sistema per verificare
i requisiti, la generazione di test case e lo sviluppo di test per i requisiti per
verificare la testabilità.
In particolare, le revisioni sono periodiche e coinvolgimento del personale
del cliente e dell'appaltatore, possono essere di tipo formali e informali
Il successo di queste tecniche dipende anche dalla buona comunicazione
tra sviluppatori, clienti e utenti.
18

Domande di Controllo della Revisione
Per controllare la corretta revisione dei requisiti, si va a verificare se i
requisiti soddisfano alcune domande:
Verificabilità: il requisito è realisticamente verificabile?
Comprensibilità: il requisito è stato compreso correttamente?
Tracciabilità: l'origine del requisito è chiaramente indicata?
Adattabilità: è possibile modificare il requisito senza avere un grande
impatto su altri requisiti?
Gestione dei Requisiti
È il processo di gestione dei requisiti mutevoli durante il processo di
ingegneria dei requisiti e lo sviluppo del sistema.
Infatti, nuovi requisiti emergono man mano che un sistema viene
sviluppato e dopo che è entrato in uso. In particolare, i manager devono
tenere traccia dei requisiti individuali e mantenere i collegamenti tra i
requisiti e le loro dipendenze in modo da poter valutare l'impatto delle
modifiche ai requisiti.
Infine, devono stabilire un processo formale per presentare delle proposte
di modifica ai requisiti del sistema.
Elementi a Supporto della Gestione dei Requisiti
La gestione dei requisiti coinvolge alcune attività e alcune risorse
importanti: l'identificazione dei requisitisi basa sul fatto che ogni requisito
deve essere identificato in modo univoco per garantire che possa essere
utilizzato con altri requisiti, il processo di gestione del cambiamento
coinvolge l'insieme di attività che valutano l'impatto e il costo dei
cambiamenti.
Le politiche di tracciabilità definiscono le relazioni tra i requisiti e la
progettazione del sistema che devono essere illustrate della
documentazione del sistema, infine, l'utilizzo di strumenti di supporto
permettono di semplificare le attività di gestione dei requisiti e
19

coinvolgono diversi tipi di strumenti; ad esempio, strumenti complessi
come i sistemi di gestione dei requisiti, e sistemi semplici come i fogli di
calcolo e i sistemi di database.
Modifica dei Requisiti
Spesso per vari motivi è necessario proporre e cercare di applicare delle
modifiche per risolvere dei problemi e per migliorare il sistema.
Ad esempio, le cause possono essere: l'introduzione di nuovo hardware e
nuove librerie software, la necessità di interagire con altri sistemi,
l'introduzione di nuove priorità aziendali, nuove legislazioni e regolamenti
e nuove richieste di aggiunta di nuove funzionalità.
Queste
attività vengono indicate attraverso la seguente espressione:
"analisi del problema e specifica del cambiamento". Il processo per gestire
questa richiesta di modifica inizia in una fase viene analizzato il problema
o la proposta di modifica per verificarne la validità.
Questa analisi permette di proporre delle modifiche dei requisiti o decidere
di ritirare la richiesta. La decisione dipende molto dal costo della modifica
e dalla difficoltà di applicare la modifica.
L'effetto delle modifiche proposte viene valutato utilizzando le
informazioni di tracciabilità e la conoscenza generale dei requisiti di
sistema.
Una volta completata questa analisi, viene presa la decisione se procedere
o meno con la modifica dei requisiti. Se la modifica è accettata, viene
applicata la modifica e il documento dei requisiti e, ove necessario, la
progettazione e l'implementazione del sistema è modificata.
Ovviamente, se la documentazione del sistema è ben organizzato, chiara e
completa, allora, le modifiche potranno essere facilmente implementate.
20|

Processo di Gestione dei Cambiamenti (Semplificato)
Modificare il documento dei requisiti e altri
documenti per riflettere il cambiamento
Discutere i problemi dei requisiti
e proporre modifiche
Identificare
Il problema
Revisione dei
requisiti
Analisi del problema
e specifica del
cambiamento
Analisi del
cambiamento
e dei costi
Implementazione
dei cambiamenti
Valutare gli effetti del cambiamento su
gli altri requisiti
I clienti possono fraintendere i requisiti e il loro
contesto e suggerire modifiche non necessarie
Con l'ausilio di informazioni di tracciabilità
• Rejected request
Change
request
request
Vind drecty
Req list
affected
1 and depcod
TENUINUNTAN
Requisments changs lis
Requirement
il rischio è troppo alto
Reperiod roques
Accepted
Propose
requirements
changes
Rejected request
Customer
information
e modifiche conseguenti potrebbero
essere inaccettabili per l'utente/cliente
Rejocted request
Ous orch
information
trattative con i clienti
il costo/tempo richiesto per l'implementazione
del cambiamento è troppo alto/lungo
Processo di Gestione dei Cambiamenti (Dettagliato)
21

Tracciabilità
La tracciabilità dei requisiti è una componente della gestione dei requisiti.
In particolare la tracciabilità definisce il grado in cui può essere stabilita una
relazione tra due o più prodotti del processo di sviluppo. Questa relazione
può essere di tipo predecessore-successore o di tipo primario
subordinato. In particolare, queste relazioni permettono di definire dei
percorsi di allocazione o dei flusso dei prodotti realizzati durante lo
sviluppo del software
Esempi di Documenti di Tracciabilità
Functoral deviol
Code
Ches pren
Page 45
Page 18
Page 30
Page 130
201
74.104
22

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
Dispensa -L5 - Sviluppo del software agili
Prof. Agostino Poggi
A.A. 2024/2025

Glossario
User stories
Descrizione generale e informale di una funzionalità software presentata
dall'utente finale con lo scopo di articolare il modo in cui questa
funzionalità software fornirà valore al cliente.
Scenari
Descrizioni in modo narrativo che raccontano la storia dell'interazione di
un utente con un prodotto. Forniscono un contesto più dettagliato rispetto
alle storie degli utenti, introduce le motivazioni, le azioni e il flusso
complessivo di interazione con il prodotto.
Metodologia agile
Rappresentano un approccio allo sviluppo del software basato sulla
distribuzione continua di software efficienti creati in modo rapido e
iterativo. Non prevedono regole da rispettare tassativamente nell'ambito
dello sviluppo del software.
Lo sviluppo software agile consiste nel rilasciare rapidamente modifiche al
software in piccole porzioni con l'obiettivo di migliorare la soddisfazione
dei clienti. Utilizzano approcci flessibili e il lavoro di gruppo per
concentrarsi sul miglioramento continuo.
I team sono costituiti da pochi sviluppatori e si organizzano in autonomia.
Collaborano direttamente con i rappresentanti aziendali tramite incontri
periodici durante l'intero ciclo di vita dello sviluppo del software.
Le attività di stesura della documentazione software sono limitate.
Permette di integrare le modifiche in qualsiasi fase del ciclo di vita.
Caratteristiche principali dello sviluppo agile
È basato su serie di versioni e/o incrementi, le attività di specifica,
progettazione e implementazione sono intercalate, il rilascio di nuove
versioni del software è frequente.

C'è un uso estensivo di tool per ridurre i tempi di sviluppo, la
documentazione fornita è minima. La valutazione del lavoro è fatta sul
codice realizzato, il cliente è coinvolto nelle attività.
Si usa il rilascio incrementale del software, il focus è sulle persone e non sui
processi, si cerca di rendere il software prodotto semplice e comprensibile.
Infine, non c'è nessuna contrarietà a valutare e ad approvare delle richieste
di cambiamenti di parti del sistema già sviluppate.
Sviluppo e rilascio rapido del software
Il software deve evolversi rapidamente e lo sviluppo plan-driven non
soddisfa queste esigenze.
Lo sviluppo agile riduce i tempi di consegna ed è basata su serie di versioni
e/o incrementi e un frequente rilascio di versioni.
Le attività di specifica, progettazione e implementazione sono intercalate,
e per velocizzare lo sviluppo si fa un uso estensivo di tool.
La realizzazione di documentazione è minima e la valutazione del lavoro è
fatta sul codice realizzato.
Applicabilità dello sviluppo agile è possibile quando: i) il sistema è piccole
o medie dimensioni, il cliente si Impegna a partecipare al processo di
sviluppo e il numero di regole e regolamenti esterni che influenzano lo
sviluppo del software è limitato.
Extreme programming (XP)
È un metodo agile basato sull'uso estremo dello sviluppo iterativo.
I requisiti sono espressi come user story o scenari. Gli sviluppatori
suddividono queste storie in piccoli rilasci di attività di sviluppo. Nuove
versioni possono essere create e testate più volte al giorno Gli Incrementi
vengono rilasciati ai clienti ogni 2 settimane. Le funzionalità che forniscono
il maggior valore aziendale vengono sviluppate per prime
Le attività partono da un insieme di user story che sono state discusse con
il cliente, con il personale del cliente e della software house.
4

Gli sviluppatori suddividono queste user story in piccoli rilasci di attività di
sviluppo.
I rilasci del sistema sono frequenti e aggiungono funzionalità in modo
incrementale. La scelta dei rilasci da effettuare dipende dalle priorità
indicata dal diagramma.
XP & Principi del Metodo Agile
I principi dei metodo agili identificano alcune azioni e valutazioni
fondamentali. La prima è sicuramente lo sviluppo del software basato sul
rilascio incrementale di "pezzi" di codice che implementano in genere una
o in certi casi più funzionalità e, la seconda ha l'obiettivo di coinvolgere il
cliente o un rappresentante del cliente durante lo sviluppo del sistema,
cercando di riuscire a mantenere la sua presenza per tutto il periodo di
sviluppo.
Due valutazioni principali sono la maggiore importanza nello sviluppo del
software data alla qualità delle persone rispetto ai processi di sviluppo e la
disponibilità all'introduzione di cambiamenti se questi comportano dei
miglioramenti.
XP ha un focus tecnico e non è facile da integrare con la pratica gestionale
nella maggior parte delle organizzazioni.
Di conseguenza, mentre lo sviluppo agile utilizza le pratiche di XP, il metodo
definito originariamente non è ampiamente utilizzato
XP e Storie degli Utenti
Come introdotto precedentemente, con XP, un cliente o un utente fa parte
del team XP ed è responsabile delle decisioni sui requisiti.
In particolare, i requisiti degli utenti sono espressi come user story o
scenari, il team di sviluppo li suddivide in attività di implementazione.
Queste attività sono la base della pianificazione e delle stime dei costi e,
infine, il cliente sceglie le storie da includere nella prossima versione in
base alle proprie priorità e alle stime del programma.

Diagramma - Ciclo di Sviluppo XP
Scleziona le
user stories
Scomponi le
stories in task
Pianifica il rilascio
Valuta il sistema
Rilascia il
software
Sviluppa, integra
e testa il software
Sviluppo guidato dai test
Lo sviluppo del software guidato dai test, richiede che i test vengano scritti
prima della scrittura del codice dei requisiti (sviluppo test-first). In genere i
test sono definiti ed eseguiti usando il framework di test come Junit.
Ogni volta che viene aggiunta una funzionalità tutti i nuovi test e quelli
precedenti devono essere eseguiti automaticamente.
L'esecuzione permette di rilevare i problemi introdotti dal nuovo codice.
Tutti i test precedenti e nuovi vengono eseguiti automaticamente quando
viene aggiunta una nuova funzionalità, controllando così che la nuova
funzionalità non abbia introdotto errori.
Tutti i test devono essere eseguiti correttamente prima di poter aggiungere
altro codice. Tuttavia, lo sviluppo guidato dai test deve gestire alcuni
problemi.
È noto che i programmatori preferiscono la programmazione ai test e, in
certi casi, non sono affidabili, infatti, spesso prendono scorciatoie per
scrivere i test e spesso i risultati non sono affidabili.
Inoltre, alcuni test possono essere molto difficili da scrivere in modo
incrementale, è difficile costruire un set di test che si possa dire completo.
Infine, i clienti, proponitori di bel numero di requisiti potrebbero aiutare i
tester, ma spesso sono riluttanti a essere coinvolti nel processo di test.

Programmazione a coppie
In un ambiente agile, i programmatori lavorano in coppia e sviluppando
codice insieme e si siedono insieme allo stesso computer.
Questo modo di lavorare agisce come un processo di revisione informale
poiché ogni riga di codice viene esaminata almeno da due persona.
Le coppie di persone vengono create dinamicamente, facendo si che
queste lavorino con diverse persone e su diverse parte del software e
quindi permette a tutti i membri del team di lavorare insieme durante il
processo di sviluppo.
Questo modo di procedere, permette ai membri del team di condividere
una buona conoscenza del codice e la capacità di diffondere questa
conoscenza in tutto il team.
In particolare, la condivisione delle conoscenze è importante in quanto
riduce i rischi complessivi di un progetto quando dei membri del team se
ne vanno o non sono presenti.
Infine, si dice che il lavoro in coppia non è necessariamente inefficiente.
Infatti, diversi studi hanno provato che in una buona parte dei casi una
coppia è più efficiente di due programmatori che lavorano separatamente.
Metodi agili e manutenzione del software
La maggior parte delle organizzazioni spende di più per la manutenzione
del software esistente che per lo sviluppo di nuovo software.
Se i metodi agili vogliono avere successo, devono supportare anche la
manutenzione.
Una criticità in questo caso è il poco interesse a fornire, della
documentazione dettagliata.
Tuttavia, il team di sviluppo che ha realizzato il sistema è ancora a
disposizione, allora la manutenzione sarà ancora possibile, ma, se questo

team di sviluppo non è più a disposizione, allora la manutenzione sarà
molto difficile e potrebbe creare grossi problemi.
Problemi della manutenzione agile
Ci sono diversi motivi per cui è difficile fare la manutenzione di un sistema
sviluppato con tecniche agili.
Il motivo principale è sicuramente la mancanza di documentazione del
prodotto. Un secondo motivo è riuscire a mantenere i clienti coinvolti nello
sviluppo e a mantenere la continuità del team di sviluppo.
Per i sistemi di lunga durata, l'uso dello sviluppo agile è un gran rischio.
Infatti, con il passar del tempo gran parte degli sviluppatori originali
potrebbero essere passati a un'altra azienda e quindi, senza
documentazione e pochi o nessuna persona che ha lavorato nello sviluppo
del sistema, sarà molto difficile mantenere il sistema in servizio.
Scelta tra metodi agili e guidati dai piani
Si possono fare delle domande che possono permettere di scegliere se
utilizzare i metodi agili o i metodi guidati dai piani:
È importante avere una specifica e un progetto molto dettagliati prima di
passare all'implementazione? In tal caso, probabilmente è necessario
utilizzare un approccio basato sul piano.
Una strategia di consegna incrementale, in cui si consegna il software ai
clienti e si ottiene un feedback rapido da loro, è realistica? In tal caso,
considera l'utilizzo di metodi agili.
In altri casi si possono dare delle risposte a delle domande:
Quanto è grande il sistema in fase di sviluppo? I metodi agili sono più
efficaci in un team co-localizzato relativamente piccolo, mentre i metodi
basati sulla pianificazione sono più efficaci per i sistemi di grosse
dimensioni anche con diversi team localizzati in diverse parti del mondo.

Che tipo sistema è in fase di sviluppo? I sistemi che richiedono molte analisi
prima dell'implementazione necessitano di una progettazione abbastanza
dettagliata per eseguire questa analisi
Qual è la durata prevista del sistema? I sistemi di lunga durata richiedono
una documentazione dettagliata e quindi devono essere sviluppati con
metodi basati sulla pianificazione. I sistemi di corta durata possono essere
sviluppati con un metodo agile.
Il sistema è soggetto a regolamentazione esterna? Se un sistema è
regolamentato, sarà probabilmente richiesto di produrre una
documentazione dettagliata e quindi devono essere sviluppati con metodi
basati sulla pianificazione.
Quanto sono bravi i designer e i programmatori nel team di sviluppo? A
volte si sostiene che i metodi agili richiedano livelli di abilità più elevati
rispetto agli approcci basati su piani in cui i programmatori traducono
semplicemente un documento di progetto dettagliato in codice.
Coinvolgimento del Cliente
Il ruolo del cliente nel processo di test è quello di aiutare a sviluppare test
di accettazione per le storie che devono essere implementate nella
prossima versione del sistema.
Il cliente che fa parte del team aiuta a definire i test man mano che lo
sviluppo procede.
Tutto il nuovo codice viene quindi convalidato per garantire che sia ciò di
cui il cliente ha bisogno.
Tuttavia, spesso le persone che adottano il ruolo del cliente hanno poco
tempo a disposizione e quindi non possono lavorare a tempo pieno con il
team di sviluppo.
In particolare, potrebbero ritenere che fornire i requisiti sia stato un
contributo sufficiente e quindi potrebbero essere riluttanti a essere
coinvolti nel processo di test.

Automazione dei Test
Automazione dei test significa che i test vengono scritti come componenti
eseguibili prima che l'attivita venga implementata.
Questi componenti di test dovrebbero essere autonomi, dovrebbero
simulare l'invio di input da testare e dovrebbero verificare che il risultato
soddisfi le specifiche di output.
Un framework di test automatizzato (ad esempio Junit) è un sistema che
semplifica la scrittura di test eseguibili e l'invio di una serie di test per
l'esecuzione.
Poiché i test sono automatizzati, deve esserci sempre una serie di test che
possono essere eseguiti rapidamente e facilmente. Ogni volta che viene
aggiunta una funzionalità al sistema, i test possono essere eseguiti e i
problemi introdotti dal nuovo codice possono essere rilevati
immediatamente.
Problemi dello Sviluppo basato sui Test
I programmatori preferiscono la programmazione ai test e talvolta
prendono scorciatoie quando scrivono i test.
Ad esempio, possono scrivere test incompleti che non controllano tutte le
possibili eccezioni che possono verificarsi. Alcuni test possono essere
molto difficili da scrivere in modo incrementale.
Ad esempio, in un'interfaccia utente complessa, è spesso difficile scrivere
"unit test" (i.e., test di unità che in genere corrispondono alle classi) per il
codice che implementa la "logica di visualizzazione" e il flusso di lavoro tra
le schermate.
E difficile giudicare la completezza di una serie di test. Infatti, sebbene si
possono sviluppare molti test di sistema, il set di test a disposizione
potrebbe non fornire una copertura completa.
10

Refactoring
La saggezza convenzionale nell'ingegneria del software è progettare per il
cambiamento e quindi si dice che vale la pena dedicare tempo e fatica ad
anticipare i cambiamenti in quanto ciò riduce i costi più avanti nel ciclo di
vita.
Tuttavia, XP sostiene che ciò non vale la pena poiché i cambiamenti non
possono essere anticipati in modo affidabile e propone un costante
miglioramento del codice (refactoring) per rendere più facili le modifiche
quando devono essere implementate.
Il team di programmazione cerca possibili miglioramenti del software e
apporta questi miglioramenti anche dove non ce n'è bisogno immediato.
Quest'ultima soluzione permette di migliorare la comprensibilità del
software e quindi riduce la necessità di documentazione e rende le
modifiche più facili da apportare perché il codice è ben strutturato e chiaro.
Tuttavia, alcune modifiche richiedono il refactoring dell'architettura e
questo può essere molto più costoso.
Esempi di refactoring
Alcuni esempi di refactoring sono i seguenti: si riorganizza una gerarchia di
classi per rimuovere il codice duplicato, si riordinano e rinominano degli
attributi e metodi per renderli più facili da capire. Si sostituisce del codice
inline (presente in diverse classi) con chiamate a metodi che sono stati
inclusi in una libreria di programmi.
Principi di refactoring
Sono stati individuati alcuni principi che possono aiutare ad effettuare del
buon refactoring.
In particolare si consiglia: di evitare di eseguire contemporaneamente sia il
refactoring che l'aggiunta di funzionalità, di verificare la disponibilità di
buoni test prima di iniziare il refactoring, di eseguire i test il più spesso
possibile per identificare velocemente gli errori.

Il refactoring comporta spesso molte modifiche localizzate che si
traducono in un cambiamento su larga scala.
Se i rilasci sono di piccole dimensioni e il test viene eseguito dopo ogni
passaggio, le attività di refactoring dovrebbero essere ridotte al debug.
Problemi pratici dei metodi agili
I metodi agili sono più appropriati per lo sviluppo di nuovo software,
piuttosto che per la manutenzione del software.
Tuttavia, la maggior parte dei costi del software nelle grandi aziende deriva
dal mantenimento dei sistemi software esistenti.
Come è già stato scritto, i metodi agili sono stati progettati per piccoli
team, ma gran parte dello sviluppo software ora coinvolge progetti di
grandi dimensioni con team distribuiti in tutto il mondo e quindi un
approccio agile, che in genere non dà molto importanza alla
documentazione non è per niente adatto a far collaborare dei team che
non hanno un documentazione comune e dettagliata che gli permette di
condividere le attività di sviluppo.
L'informalità dello sviluppo agile è incompatibile con l'approccio legale alla
definizione del contratto comunemente utilizzato nelle grandi aziende.
Metodi agili e manutenzione del software
La maggior parte delle organizzazioni spende di più per la manutenzione
del software esistente che per lo sviluppo di nuovo software.
Quindi, se i metodi agili devono avere successo, devono supportare sia la
manutenzione che lo sviluppo originale. In particolare, si dice che I sistemi
sviluppati utilizzando un approccio agile sono mantenibili, senza una
documentazione dettagliata, solo se il team di sviluppo originale non può
essere mantenuto.
I problemi principali per poter utilizzare i metodi agili per attività di
manutenzione sono: la mancanza di documentazione dettagliata, la
difficoltà a mantenere il cliente o delegato del cliente coinvolto nel
12

processo di sviluppo, la difficoltà a "conservare" le persone coinvolte nello
sviluppo del sistema.
Per i sistemi di lunga durata, questo è un vero problema in quanto gli
sviluppatori originali non lavoreranno sempre sul sistema.
Problemi contrattuali
Inoltre, l'informalità dello sviluppo agile è incompatibile con l'approccio
legale alla definizione del contratto comunemente utilizzato nelle grandi
aziende.
Infatti, gran parte dei contratti software per sistemi personalizzati si basa
su una specifica che stabilisce cosa deve essere implementato, mentre
nello sviluppo agile le attività da eseguire, in genere, sono identificate
durante lo sviluppo, via via, che sono implementati gli incrementi che
realizzeranno il sistema finale e quindi non è possibile una specifica
completa e che si è sicuri che non abbia bisogno di modifiche.
Una possibile alternativa è cercare di riuscire ad avere un contratto che
paghi per il tempo dello sviluppatore piuttosto che per la funzionalità.
Questo è visto come un rischio elevato per molti uffici legali perché quello
che deve essere consegnato non può essere garantito.
Problemi organizzativi
Le aziende di ingegneria tradizionali hanno una cultura dello sviluppo
basato su piani, poiché questa è la norma nell'ingegneria.
Si possono fare delle domande che possono permettere di scegliere se
utilizzare i metodi agili o i metodi guidati dai piani:
È pratica organizzativa standard sviluppare una specifica di sistema
dettagliata? In genere si, ma in certi casi un metodo agile può essere
applicato se il sistema è di piccole dimensioni e non è previsto un lungo
tempo del suo utilizzo. Inoltre, un metodo agile può essere usato per lo
sviluppo di parti di un sistema (e.g., per la GUI del sistema).
13

I rappresentanti dei clienti saranno disponibili per fornire feedback sugli
incrementi del sistema? Inizialmente si, ma poi per sovraccarico di lavoro
o perché si pensa che il lavoro possa andare avanti senza la loro presenza i
rappresentare potrebbero non essere presenti in diversi momenti.
Lo sviluppo agile informale può adattarsi alla cultura organizzativa della
documentazione dettagliata? In genere, non è semplice passare da un
approccio basato principalmente sul codice a uno che come punto di
partenza ha la documentazione dettagliata e precisa.
Gestione agile dei progetti
La principale responsabilità dei project manager che sta seguendo le
attività di sviluppo del sistema software è gestire il progetto in modo che il
software venga consegnato in tempo e entro il budget pianificato per il
progetto.
L'approccio standard alla gestione dei progetti è basato sul piano. I
manager elaborano un piano per il progetto che mostra cosa dovrebbe
essere consegnato, quando dovrebbe essere consegnato e chi lavorerà allo
sviluppo dei risultati del progetto.
La gestione agile del progetto richiede un approccio diverso, adattato allo
sviluppo incrementale e alle pratiche utilizzate nei metodi agili.
Scrum
È un metodo agile che si concentra sulla gestione dello sviluppo iterativo
del software tramite degli sprint.
Gli sprint sono dei brevi periodi di tempo in cui un team collabora per
completare una determinata quantità di lavoro.
Gli sprint sono di durata fissa, normalmente 2-4 settimane.
Le attività di scrum sono basate su tre fasi.
La fase iniziale è una fase di pianificazione generale in cui si stabiliscono gli
obiettivi generali del progetto e si progetta l'architettura software.
14

La seconda fase esegue una serie di cicli di sprint, in cui ogni ciclo sviluppa
un incremento del sistema.
Infine, la fase finale conclude il progetto, completa la documentazione
richiesta come un sistema di aiuto e manuali utente e valuta le lezioni
apprese dal progetto.
Il punto di partenza per la pianificazione è il backlog del prodotto, che è
l'elenco del lavoro da svolgere sul progetto La fase di selezione coinvolge
tutto il team di progetto che lavora con il cliente per selezionare le
caratteristiche e le funzionalità dal backlog del prodotto da sviluppare
durante lo sprint.
Selezionate le caratteristiche e le funzionalità, il team si organizza per
sviluppare il software.
Review work
to be done
Select
items
Plan
sprint
Sprint
Review
sprint
Product
backlog
Sprint
backlog
Potentially
shippable
software
Diagramma del Ciclo di Sprint
Durante lo sviluppo il team è isolato dal cliente e dall'organizzazione, con
tutte le comunicazioni canalizzate attraverso il cosiddetto "Scrum master".
Il ruolo dello Scrum master è proteggere il team di sviluppo da distrazioni
esterne.
Alla fine dello sprint, il lavoro svolto viene rivisto e presentato agli
stakeholder. Inizia quindi il ciclo di sprint successivo.
Lo "Scrum master" è un facilitatore che organizza riunioni quotidiane, tiene
traccia dell'arretrato di lavoro da svolgere, registra le decisioni, misura i
15

progressi rispetto all'arretrato e comunica con i clienti e il management al
di fuori del team.
L'intero team partecipa a brevi riunioni giornaliere in cui tutti i membri del
team condividono informazioni, descrivono i loro progressi dall'ultima
riunione, i problemi che sono sorti e cosa è pianificato per il giorno
successivo.
Ciò significa che tutti i membri del team sanno cosa sta succedendo e, se
sorgono problemi, possono ripianificare il lavoro a breve termine per
affrontarli.
Scrum multi-team
Scrum è stato esteso per permettere lo sviluppo con l'uso di diversi team.
In questo caso, ogni team ha uno "Scrum owner" e uno "Scrum master", e
ogni team sceglie uno "product owner" e uno "Scrum architect" che
collabora per progettare ed evolvere l'architettura complessiva del
Sistema.
Come accennato precedentemente, lo "Scrum master" è un formatore,
mediatore, moderatore e assistente del team di sviluppo. Il "product
owner" è responsabile della massimizzazione del valore del prodotto
risultante dal lavoro del team di sviluppo e, infine, lo "Scrum architect" è
coinvolto quotidianamente nello sprint, partecipa alle riunioni stand-up,
discute i requisiti con l'organizzazione, prende la prima decisione di
progettazione globale, suddivide gli elementi del backlog in attività e lavora
su di essi.
Le date dei rilasci dei prodotti da parte di ciascun team sono allineate in
modo da produrre un sistema dimostrabile e completo.
Ogni giorno lavorativo c'è una riunione in cui i rappresentanti di ciascun
team si incontrano per discutere i progressi e pianificare il lavoro da
svolgere.
16

Benefici dell'uso di Scrum
I vantaggi del suo uso sono molteplici, come prima cosa, il prodotto è quasi
sempre suddiviso in una serie di blocchi gestibili e comprensibili, non c'è
nessun problema a fare delle modifiche visto che queste permettono di
migliore il codice e quindi il sistema, la forte interazioni tra le parti coinvolte
garantisce all'intero team una buona visibilità su tutto il sistema e su tutte
le decisioni prese e quindi c'è sempre una buona comunicazione all'interno
del team e quasi sempre con gli stakeholder del sistema.
Quindi, questo in genere comporta che in gran parte dei casi, i clienti
vedono la consegna puntuale degli incrementi e ottengono un feedback su
come funziona la versione corrente del sistema e quindi viene stabilita la
fiducia tra clienti e sviluppatori e viene creata una cultura positiva in cui
tutti si aspettano che il progetto abbia successo.
Scalabilità dei metodi agili
I metodi agili si sono dimostrati efficaci per progetti di piccole e medie
dimensioni che possono essere sviluppati da un piccolo team co-
localizzato.
Oggigiorno, una buona parte dei sistemi che si vogliono realizzare sono di
grossa dimensione e spesso si vuole "scalare" su sistemi più grandi
cercando di mantenere almeno in parte l'uso di metodi agili e soprattutto
di mantenere i fondamenti agili: pianificazione flessibile, rilasci frequenti
del sistema, integrazione continua, sviluppo basato su test e buone
comunicazioni di gruppo.
Scalabilità verticale e orizzontale
La scalabilità verticale riguarda l'utilizzo di metodi agili per lo sviluppo di
sistemi software di grandi dimensioni che non possono essere sviluppati da
un piccolo team.
La scalabilità orizzontale riguarda il modo in cui i metodi agili possono
essere introdotti in una grande organizzazione con molti anni di esperienza
nello sviluppo di software
17

Sviluppo di sistemi di grossa dimensione
I sistemi di grandi dimensioni ei relativi processi di sviluppo sono spesso
vincolati da norme e regolamenti esterni che limitano il modo in cui
possono essere sviluppati.
Inoltre, i grandi sistemi hanno tempi di approvvigionamento e sviluppo
lunghi e quindi può essere difficile mantenere team coerenti che
conoscano il sistema in quel periodo poiché, inevitabilmente, le persone
passano ad altri lavori e progetti.
Infine, i grandi sistemi di solito hanno un insieme diversificato di
stakeholder. È praticamente impossibile coinvolgere tutti gli stakeholder
nel processo di sviluppo.
Scalabilità verticale di grossi sistemi
Realizzare grossi sistemi con un approccio agile è molto difficile, comunque
vengono fatti dei suggerimenti per andare avanti con quel tipo di soluzione:
Un approccio completamente incrementale all'ingegneria dei requisiti è
impossibile da realizzare per un grossi sistemi e quindi è necessario fare dei
compromessi, ad esempio, integrando il codice con della documentazione.
Durante lo sviluppo non può esserci un singolo cliente o suo
rappresentante a seguire il lavoro, ma più persone si devono distribuire
questo incarico.
Devono essere progettati e utilizzati meccanismi di comunicazione tra i
team. team e stakeholder devono concordare tempi e frequenza delle
riunioni e definire delle regole su come distribuire le informazioni
L'integrazione continua è praticamente impossibile. Tuttavia, il team e gli
stakeholder devono concordare dei range temporali entro i quali
completare i build del sistema e fare dei rilasci degli incrementi.
18

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L6-Modelli dei Sistemi e UML (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Modellazione del Sistema
Il software è complesso e spesso conoscere in dettaglio il sistema non è necessario. I modelli permettono di
definire delle viste semplificate e permettono di concentrarsi sulle questioni importanti. Inoltre, aiutano a
comprendere le funzionalità del sistema e a comunicare con il cliente, Per modellare un sistema software si
usano delle rappresentazioni astratte, delle viste multiple (i.e., diversi modelli) e, ovviamente, si usa una
notazione grafica.
Un buon modello dovrebbe introdurre ciò che è essenziale, usare una notazione ben definita è velocizzare la
modellizzazione utilizzando specifici strumenti di supporto. È importante capire che un modello di sistema
non è una rappresentazione completa di sistema. Infatti un buon modello, tralascia volutamente i dettagli
per facilitarne la comprensione. Un modello è un astrazione del sistema studiato piuttosto che una
rappresentazione alternativa dello stesso sistema.
Ovviamente, anche la modellizzazione ha delle debolezze: non è utile per rappresentare i requisiti di sistema
non funzionali, spesso si genera troppa documentazione, spesso si generano dei modelli troppo dettagliati e
quindi sono difficili da capire per gli utenti.
Ogni modello può essere espresso a diversi livelli di precisione, il grado di dettaglio dipende da chi sta
visualizzando il modello e perché ha bisogno di visualizzarlo. Ovviamente i modelli di buona qualità sono
collegati alla realtà e tutti i modelli semplificano la realtà. Gran parte dei sistemi non può essere
rappresentato tramite un unico modello. Infatti, ogni sistema non banale viene rappresentato tramite un
piccolo insieme di modelli quasi indipendenti. La figura qui sotto presenta due esempi di modelli.
Descrbed by
Tipi di Modelli
Esistono tre tipi principali di modelli.
I modelli predittivi sono realizzati prima dell'inizio dell'implementazione e hanno l'obiettivo di prevede come
sarà il software. Il loro utilizzo permette di pianificare le risorse e valutare i rischi.
I modelli estrattivi hanno l'obiettivo di estrarre del codice da un sistema esistente mediante analizzare il
codice e le sue proprietà. Il loro utilizzo permette di rispondere a domande specifiche sul software.
Infine, i modelli prescrittivi definiscono un insieme di regole e vincoli su come costruire o far evolvere il
software.

Prospettive dei Sistemi Software
È possibile sviluppare modelli diversi per rappresentare il sistema con diverse prospettive, ad esempio:
Una prospettiva di contesto (esterno), in cui si modella il contesto o l'ambiente del sistema
Una prospettiva di interazione, in cui si modellano le interazioni tra un sistema e il suo ambiente o tra i
componenti di un sistema
Una prospettiva strutturale, in cui si modella la struttura di un sistema e dei dati che vengono elaborati dal
sistema
Una prospettiva comportamentale, in cui si modella il comportamento dinamico del sistema e come risponde
agli stimoli (dati e arrivi di eventi) |
Riuso e attività nell'ambito dei modelli
Come avviene per il software, è utile anche riutilizzare i modelli utilizzati in sistemi precedenti. Infatti, questi
modelli possono essere utilizzati durante l'ingegneria dei requisiti di un nuovo sistema, aiutano a chiarire
cosa fa il sistema esistente e possono essere utilizzati come base, permettono discutere e poi comprendere
i suoi punti di forza e di debolezza, aiutare a spiegare i requisiti proposti ad altre parti interessate del sistema
e, infine, aiutano a discutere e poi comprendere le proposte di progettazione e documentare il sistema per
l'implementazione.
Durante lo sviluppo dei modelli utili per fornire le "basi di partenza" per realizzare un sistema software,
vengono eseguite diverse attività. Il tutto parte con la creazione di modelli all'interno di un cosiddetto "spazio
dei modelli".
Questi modelli possono essere estesi e raffinati per creare un nuovo modello (in questo casi si parla di "model
trasformation"). Inoltre, un modello può essere trasformato in un programma software (in questo casi si
parla di "forward engineering").
Un componenti software e un programma possono essere considerati dei modelli facente parte del
cosiddetto "spazio del codice". Anche un programma può essere esteso e raffinata creando un nuovo
programma (in questo casi si parla di "refactoring").
Infine un programma può essere trasformato in un modello di sistema (in questo casi si parla di *reverse
engineering").
Attività nell'Ambito dei Modelli
Altro modello
dentera
Altre modelle
di sistema
Forward
engineering
Rofactoring
Model
transformation
Code
space
Modello
"stett
Reverse
engineering
Model space

UML
L'UML (Unified Modeling Language) è una notazione grafica standard industriale internazionale utilizzata per
descrivere, visualizzare, costruire e documentare i manufatti di un sistema software. Lo standard UML utilizza
diagrammi di classe per rappresentare visivamente la propria notazione.
diagrammi delle classi UMiL consistono in classi e nelle relative istanze (oggetti) e intertacce, e creano
relazioni gerarchiche e associazioni tra questi elementi
UML (acronimo di Unified Modeling Language) è uno "standard de facto" per la definizione dei modelli
durante lo sviluppo del software e fornisce più diagrammi per l'acquisizione di diverse viste per rappresentare
il sistema o parti del sistema.
UML è un linguaggio standard per visualizzare, specificare, costruire e documentare sistemi software ed è
integrato dal linguaggio OCL e dallo standard XMI.
È semplice perché richiede solo un insieme limitato di concetti e simboli, è espressivo perché è applicabile a
un ampio spettro di sistemi e metodi, è utile perchè si concentra solo su quegli elementi necessari
all'ingegneria del software, ha un uso coerenze dei suoi concetti e i relativi elementi perché lo stesso concetto
e lo stesso simbolo possono essere applicati allo stesso modo dappertutto.
Infine, si dice che è estensibile perché gli utenti e i costruttori di strumenti possono avere una certa libertà
di estendere la notazione.
OCL (acronimo di Object Constraint Language) è un linguaggio che permette di definire dei vincoli attraverso
delle condizioni logiche sullo stato e sulle operazioni di un contesto object-oriented.
XMI (acronimo di XML Metadata Interchange) è uno standard OMG per definire, scambiare e manipolare
oggetti elaborando dati in formato XML.
In particolare, XMI permette lo scambio di strutture dati ad oggetti in una maniera standard, promuovendo
la compatibilità e l'interoperabilità tra le applicazioni di diverse aziende.

Motivi del Successo di UML
Diversi studi e ricerche hanno dimostrato l'importanza dell'uso di UML
Improve Project
Communications
Better
Requirements.
Easier to maintain
51
Faster Development
40
39
Fower Defects
125
0
20
40
60
80
Source: BZ Research, August 2004
Viste di UML
UML fornisce diverse viste che sono la base per lo sviluppo dei diversi tipi di modelli. In particolare, la vista
dei casi di uso cattura e descrive i requisiti di un sistema, la vista strutturale rappresenta gli elementi
strutturali necessari per l'implementazione dei requisiti, la vista comportamentale rappresenta l'interazione
dinamica tra i componenti del sistema necessaria per l'implementazione dei requisiti, la vista di
aplementazione: descrive gli artefatti di implementazione dei sottosistemi logici definiti nella vist
trutturale e, infine, la vista dell'ambiente: definisce la modalità di distribuzione dei componenti software s
nodi hardware.
Tipi di Diagrammi UML
Structural View
Class
Object
Composite structural
Package
Implementation View
Composite structural
Component
Use Case View
Use Case
Behavioral View
Sequence
Communication
State
Activity
Timing
Interaction overview
Environment View
Deployment

Statistica dell'Uso dei Diagrammi
(%) pasn
100
90
80706050403020100
Professional developers
survey
ml
Source: Seth Rosen, June 2010|
UML Olagram
Book Quide Book Spes. Book Tot
1 Class
Composite Structure
100%
HO0%
Deployment
Object
Package
Activity
Sequence
Interaction Overview
Timing
State Machine
Toel
Course
還並系茲教茲頭酸驗茄品酸驗
Web search
Tutorial. All Sources
100%
然雖戰形桃照照歐挑桃照眼
Source: Gianna Reggio, Maurizio Lcotta, Filippo Ricca, Dicgo Cicrissi, Scptember 2013

Cless Diug un
Component Di
Depicymert De
Object Diagra
Package Diagr
Profile Diegran I - 1 (124)
Composio Stru
-3(05%)
Use Case Dag
Sale Machine
Seqence Diag
Communicano
noraction Over
Timing Diegred
1 - 06 (71.0%)|
1 - 13 (15.3%)
I-12 (14.1%)
1-30（53）
13207P）|
89 (3125)
1-2 （321
第659）
57 (57.15)
89.15)
-11 (129%)|
From Requirements Enginecring to UML. using Natural Language Processing - Survey Study - 2017|
Proprietà ed elementi dei diagrammi dei casi d'uso
Un diagramma dei casi d'uso si basa su tre entità principali: Il boundary, gli attori e i casi d'uso. Il boundary
definisce il confine del sistema.
Divide ciò che è all'interno da ciò che è all'esterno del sistema e divide i casi d'uso dagli attori. La definizione
del boundary è molto importante perché l'azienda che deve sviluppare il sistema deve lavorare sulle parti
interne al boundary, ma non ha nessun impegno sulle parti esterne boundary.
Un attore ha un nome e può rappresentare una persona o un sistema Un attore può essere rappresentato
graficamente da un omino o da una classe rettangolo con la keyword «actor». Un attore può estendere un
altro attore. Un attore può generalizzare un altro attore.
Un caso s'uso mostra le funzionalità di un sistema, presenta le interazioni tra un utente (umano o macchina)
e il sistema e semplifica la comunicazione tra sviluppatori, esperti di dominio e utenti finali. Inoltre, i caso
s'uso servono come base per il testing.
Un caso di uso identifica una funzionalità del sistema ed è rappresentato da un'ellisse contenente il nome
della funzionalità.
Un case d'uso può generalizzare un altro caso d'uso. Un caso d'uso può includere la funzionalità di un altro
caso d'uso come sua parte.
Un caso d'uso può essere utilizzato per estendere il comportamento di un altro caso d'uso. Un'estensione
può essere condizionata.
Un punto di estensione indica dove viene aggiunto un caso d'uso di estensione. I connettori tra un attore e
un caso d'uso hanno un valore
Elementi dei Casi di Uso
Il termine "caso di uso" identifica il diagramma dei casi di uso, ma anche una funzionalità del sistema. Altri
due elementi sono: l'attore, che ha un nome e può rappresentare una persona o un sistema, e il boundary

che definisce il confine del sistema e divide ciò che è all'interno da ciò che è all'esterno del sistema e
l'attore.
Un attore può essere rappresentato da un omino o da una classe rettangolo con la keyword «actor».Un
attore può estendere un altro attore. Un attore può generalizzare un altro attore (e.g., ereditarietà tra
superclasse e sottoclasse)
Un caso di uso identifica una funzionalità del sistema ed è rappresentato da un'ellisse contenente il nome
della funzionalità. Un diagramma dei casi d'uso può contenere diversi attori e casi d'uso.
un ade sue sua pri are un alto cao eso Un a ver includere a furiamena di un airo
Un'estensione può essere condizionata. Un punto di estensione indica dove viene aggiunto un caso d'uso d
estensione. I connettori tra un attore e un caso d'uso hanno un valore di molteplicità e sono utilizzati in altri
contesti.
* Generalizzare tra attori
• Generalizzazione tra casi di uso
* Inclusione tra casi di uso
* Estensione tra casi di uso
• Estensione condizionata

Esempio di caso di uso
Online Shoppin
Web
Customer
Checkou
옷
Justom
PayPal
Connettori e Valori di Molteplicità
Molteplicità Option
0..0
O.1
1.1
o.."
1.
5.5
m..n
Cardinalità
Nessuna istanza
Nessuna o un'istanza
Un'istanza
Zero o più istanze
Almeno un'istanza
Cinque istanze
Almeno m ma non più di n istanze
Cinto
수
Administrator
ATM System
Withdran
0.1
Trans
Fur
0.1
Depost
Money|
Register ATM
at bank
O.1
Read log
10

Classi, interfacce e modificatori
Una classe è rappresentata da un rettangolo che mostra il nome della classe e facoltativamente il nome dei
suoi attributi e operazioni. I compartimenti vengono utilizzati per separare i nomi della classe, degli attributi
e delle operazioni. Il simbolo che precede il nome dell'attributo e dell'operazione, indica la visibilità
dell'elemento. Una interfaccia è identificata dallo "<<Interface>>*. Oltre a un esempio di classe e interfaccia,
Bicycle
-speed: int
•Bicycie0)
-changeCadence(nea/Value: int) : void
increment: int): void
««interface»>
Bicycle
*changeCadence(parameter: ind) : void
tapply Brakes(parameter: int): void
+ is public visibility
- is private visibility
# is protected visibility
- is package visibility
qui sotto sono introdotti i simboli che rappresentano i modificatori di visibilità.
Modelli di Classe a Diverso Livello di Dettaglio
Durante lo sviluppo di un sistema, spesso avviene che all'inizio ogni classe viene introdotto inserendo solo
un suo potenziale nome e, via via, viene raffinato fino ad arrivare alla versione finale della classe.
Rectangle
Rectangle
getArea
reSize
Rectangle
height
width
Rectangle
height
width
getArea
reSize
Rectangle
height: int
width: int
getArea(): int
reSize(int, int)
Associazione
Un'associazione implica che due elementi del modello abbiano una relazione che solitamente viene
implementata come variabile di istanza in una classe. Un'associazione è rappresentata da un connettore che
può includere ruoli denominati a ciascuna estremità, cardinalità, direzione e vincoli. In certi casi si vogliono
introdurre associazioni con più di due elementi; in questo caso è possibile utilizzare un elemento a forma di
rombo Qui sotto viene introdotto due esempi di associazione con due e tre elementi.
WokProduct
Secretary
Manager
1...
supervisor
11

Generalizzazione, Nesting, Dipendenza e Realizzazione
Una generalizzazione viene utilizzata per indicare l'ereditarietà. Il connettore parte dalla classe specifica e
arriva alla super classe
Circle
adius: int
displayü: void
Il nesting è un connettore che mostra che l'elemento di origine è all'interno dell'elemento di destinazione
TopClass
Una dipendenza è una forma più debole di relazione che mostra una relazione tra un cliente e un fornitore.
In particolare, la relazione tra Mailer e Ipassenger è di dipendenza
Mailer
«cinterface»>
IPerson
*getName): String
*getAddressO : Address
Una realizzazione è una relazione tra una specifica e la sua implementazione. In particolare, la relazione tra
passender e IPerson è di realizzazione. Inoltre, Mailer utilizza l'interfaccia IPerson e passenger la fornisce
Il diagramma qui sopra può essere semplificato: passender fornisce un interfaccia e Mailer la utilizza.
Aggregazione e Composizione
Un'aggregazione viene utilizzata per rappresentare elementi (contenitori) costituiti da componenti più
piccoli. Le relazioni di aggregazione sono indicate da un connettore terminato da un rombo vuoto che punta
verso il contenitore. I componenti possono essere condivisi da diversi contenitori. È un tipo debole di
associazione in cui gli oggetti collegati sono indipendenti l'uno dall'altro. L'aggregazione è definita come una
relazione "has-a".
12

Una composizione viene utilizzata per rappresentare un unico contenitore. Le relazioni di composizione sono
indicate da un connettore terminato da un rombo nero che punta verso il contenitore. I suoi componenti
sono altamente dipendenti l'uno dall'altro. La composizione è definita come una relazione "part-of*. Se il
contenitore viene eliminato, tutte le entità a esso connesse spariscono di conseguenza.
Zampe
Diagramma di Sequenza
Un diagramma di sequenza descrive come un processo viene eseguito da un gruppo di oggetti mediante un
insieme sequenziale di interazioni. E utilizzato per modellare le interazioni tra gli attori e gli oggetti all'interno
di un sistema, mostra la sequenza delle interazioni che hanno luogo durante un particolare caso d'uso o
descrive il comportamento di una parte di un sistema e facilita l'assegnazione delle responsabilità alle classi
e aiuta a scoprire nuovi metodi e nuove classi.
Elementi del diagramma di sequenza
Se il nome della lifeline è self, indica che la lifeline rappresenta il classificatore che contiene il diagramma di
sequenza. La lifeline rappresenta la "vita" di un singolo partecipante del diagramma di sequenza. Il rettangolo
lungo la lifeline rappresenta il tempo di esecuzione. La lifeline può essere avviata e terminata. Un self
message può rappresentare una chiamata ricorsiva di un'operazione, oppure può rappresentare un metodo
che chiama un altro metodo appartenente allo stesso oggetto
tatance. Clas
Se il nome della lifeline è self.
indica che la lifeline rappresenta
il classificatore che contiene il
diagramma di sequenza
Una lifeline rappresenta un singolo
partecipante del diagramma di sequenza
Il rettangolo lungo la lifeline
rappresenta il tempo di esecuzione
La lifeline può essere
avviata e terminata
Un fragment consente di rappresentare una logica procedurale complessa in un diagramma di sequenza. 1
fragment più utilizzati sono: "alternative" che indica il costrutto if...then….else…., "option(6) che indica il
costrutto if...then..., "parallel" che permette l'elaborazione concorrente, "loop" che permette di inviare una
serie di messaggi e, infine, "region" che indica che alcune chiamate sono eseguite in una sezione critica. Qui
sotto (7) sono indicati i principali tipi di messaggi utilizzati nel diagramma di sequenza.
13

es: EnalSpiten
Messaggi usati nel diagramma di sequenza
Synchronous
Asynchronous
Reply
Find
Lost
dot(x)
Code
lost
Diagramma delle attività
Un diagramma delle attività permette di rappresentare il flusso di lavoro in un sistema. Questo diagramma
è molto simile a un diagramma di flusso che può essere considerato una versione primitiva di un diagramma
di attività. È molto utile per rappresentare situazioni in cui possono verificarsi elaborazioni parallele
nell'esecuzione di alcune attività. Infine, è utilizzato a livello aziendale per dettagliare i processi di business
che dovranno essere implementati dal sistema.
14

Esempio di Diagramma delle Attività
Tipi di Nodi di Controllo
Initial Node
Final Node
Flow Final Node
Decision & Merge Nodes
Fork & Join Nodes
Input & Output Pins
15

Deliver
Master's
thesis
Action
Master
Thes
Object node
Assess
Master's
Thesis
Input pin
Masters
Deliver
Master's
thesis
Output pin
Assess
Master's
Thesis
I due diagrammi sono equivalenti!
Decisioni
Decision
Condition
(LowPriority)
Inorenne
Allocate
(fire & highPelority)
(not fire & higherority)
nire
Concorrenza
Multiple threads
Splitting (fork)
Incident
cordinate
source
Document
Synchronization (join)
Attività di Raggruppamento
16

Le attività sono
divise tra gli attori
Swimline
Swimline
Allocate
Resources
Dispatcher
Open
Coordinate
Resources
Document
Incident
Archive
Incident
Fieldofficer-
Timeout & Signal
Wait signal
Reserve
itinerary
itinerary
Confirmed
Book
Itinerary
Send
Itinerary
Wait 48 hours
Cancel
Itinerary
Send signal
Wait timeout
Diagramma degli Stati
Il diagramma degli stati viene utilizzato per modellare il comportamento di un singolo oggetto, quando
l'oggetto ha un comportamento dinamico significativo. Questo diagramma permette di specificare la
sequenza di stati attraversati da un oggetto durante la sua vita in risposta a stimoli provenienti dall'ambiente
usato. In particolare, descrive: la storia della vita di una determinata classe, gli eventi che causano la
transizione da uno stato a un altro e le azioni che risultano da un cambiamento di stato.
Esempio di Diagramma degli Stati
17

button1&2Pressed
lini
button?Pressed
Incoerent
button1&2Pressed
buttonlPressed
button?Pressed
ธารักนใกล
linutes
81ink
Seconds |
Incremen
inute
buttonlPressed
button?Pressed
Incremen
econd
Pseudo-stato di Scelta e di Giunzione
Junctico picudo state
Stato Composto
Indica che i dettagli del componente Check
PIN sono mostrati in un diagramma separato
I due diagrammi sono equivalenti!
18

Storie dello Stato e Regioni Concorrenti
History State
Concurrent Region
un obicttivo e un comportamento differente
L'uso dell'History State indica
che se si chiude l'attività in un
certo momento, quando si fa
ripartire l'attività riparte dal
punto in cui cra stata fortala
Diagramma degli Oggetti
Il diagramma degli oggetti descrive la struttura statica di un sistema in un momento particolare e può essere
considerato un caso speciale di un diagramma di classe. Mentre un modello di classe descrive tutte le
situazioni possibili, un modello di oggetto descrive una situazione particolare. Questo diagramma è utile per
comprendere e convalidare i diagrammi di classe corrispondenti.
Esempio di Diagramma degli Oggetti
Diagramma dei Componenti
Un diagramma dei componenti mostra la relazione tra i componenti software, le loro dipendenze, la
comunicazione, la posizione e altre condizioni. Un componente è un'entità eseguibile indipendente che può
essere costituita da uno o più oggetti eseguibili e dispone di un'interfaccia pubblica utilizzata per comunicare
con altri componenti. Consente di modellare i componenti principali e le interfacce a tali componenti, Vista
la sua struttura, questo diagramma viene spesso definito "schema elettrico".
19

Esempio di Diagramma dei Componenti
0-02
Diagramma delle Strutture Composite
In diagramma delle strutture composite mostra la struttura interna di un classificatore, inclusi i suoi pun
¡ interazione con altre parti del sistema. È simile a un diagramma di classe, ma raffigura singole parti no
intere classi.
Esempio di Diagramma delle Strutture Composite
wtanson: Transion
GasPadel
Steering Wheel
When Ф
steering: Steeing Syster
Diagramma dei Package
Il diagramma dei package è usato per scomporre un sistema in unità logiche di lavoro che descrivono le loro
dipendenze. Questo diagramma fornisce viste di un sistema a più livelli di astrazione. L'uso più comune per i
diagrammi dei package è organizzare i diagrammi dei casi d'uso e i diagrammi delle classi. Tuttavia, possono
essere utilizzati per altri elementi UML
Esempio di Diagramma dei Package
controter
20

Diagramma di Comunicazione
Il diagramma di comunicazione era inizialmente chiamato "diagramma di collaborazione" ed è ora chiamato
diagramma di interazione. Questo diagramma mostra informazioni simili ai diagrammi di sequenza, ma si
basa principalmente sulle relazioni tra oggetti e lo scambio di messaggi.
Gli oggetti che devono scambiare messaggi sono legati da associazioni tra oggetti e i messaggi inviati vengono
rappresentati come brevi frecce che puntano nella direzione delle destinazioni. La sequenza dei messaggi è
ordinata attraverso una sequenza numerica.
Questo diagramma fornisce una vista alternativa al diagramma di sequenza in un formato basato sulla
struttura piuttosto che sul tempo.
Esempio di Diagramma di Comunicazione
c cacton)
4.1. createliewRegularBlog Account|customerDetais: Castome Detalk)
3.1. «coute»>
415 «cdstop>
reatellew AccountCe
1.A. sendE mallemail: Emai
heded -= trol
Ichecked - true
es: Emailsystem
thorDeta
1.1. che di AuthorDetals autherDetails: AuthorDetait)
ad:atecodentod
Diagramma di Temporizzazione
Il Diagramma di Temporizzazione viene utilizzato per visualizzare il cambiamento di stato o di valore di uno
o più elementi nel tempo. Questo diagramma può anche mostrare l'interazione tra gli eventi a tempo e i
vincoli temporali e di durata che li governano e rappresenta con un formato grafico il tempo di esecuzione
impiegato da ogni istruzione.
21

Esempio del Diagramma di Temporizzazione
Diagramma di Panoramica dell'Interazione
Il diagramma di panoramica dell'interazione è una forma di diagramma di attività in cui i nodi rappresentano
diagrammi di interazione (sequenza, comunicazione, panoramica dell'interazione e diagrammi di
temporizzazione). La maggior parte della sua notazione deriva dal diagramma di attività. Ad esempio, gran
parte dei nodi sono uguali a quelli del diagramma di attività. Tuttavia, introduce due nuovi elementi:
occorrenze di interazione ed elementi di interazione
Esempio di Diagramma di Panoramica dell' Interazione
Interaction element
Interaction occurrence
22

Diagramma di Distribuzione
Il diagramma di distribuzione mostra le relazioni fisiche tra hardware e software in un sistema. I nodi e le
connessioni sono due elementi fondamentali del diagramma: un nodo di solito rappresenta un componente
hardware nel sistema e una connessione rappresenta il percorso di comunicazione utilizzato dall'hardware
per comunicare.
Esempio di Diagramma di Distribuzione
Diagramma di Robustezza
I diagramma di robustezza è fondamentalmente un diagramma UML semplificato di comunicazione o d
equenza. Lo scopo di questo diagramma è quello di fornire un mezzo per raffinare i casi d'uso e completare
e verificare la loro correttezza. Inoltre, è necessario controllare se tutte le linee d'azione alternative e
necessarie sono state sviluppate. Queste attività permettono di scoprire tutti gli oggetti necessari alla
progettazione.
Tipi di Nodi
Boundary (Interface): permette la comunicazione tra gli attori e le parti interne del sistema
Control: funge da collante tra gli elementi di confine e quelli dell'entità, implementa la logica necessaria per
gestire i vari elementi e le loro interazioni
Entity: rappresenta un'unità informativa del sistema
Diagramma di robustezza e comunicazione
10
23

Diagramma di robustezza e sequenza
Tool per il disegno di diagrammi UML
Eclipse Papyrus ™
Modeling environment
https://app.diagrams.net/
24

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L7-Modelli e Classi di Analisi (dispensa)
Prof. Agostino Poggi
A.A. 2023/2024
1

Modello di analisi dei requisiti
Definisce delle astrazioni e non è un modello di progettazione ed è indipendente dalla piattaforma (lingua,
sistema operativo,...). Descrive le funzioni che devono essere realizzate dal sistema e raffina la descrizione
informale dei requisiti. Converte le descrizioni informali in diagrammi di flusso.
Modello di analisi orientati agli oggetti
Un modello di analisi orientati agli oggetti è rappresentato da un sistema di analisi che è il top level package
del modello. Il sistema di analisi può contenere sottosistemi o package di analisi. Un modello di analisi
orientato agli oggetti si basa sui casi di uso e sulla rappresentazione degli oggetti e dei concetti reali del
dominio del sistema. I casi di uso sono all'interno del modello di analisi e sono realizzati mediante classi di
analisi e diagrammi di interazione. Le classi di analisi rappresentano un'astrazione delle classi (ed
eventualmente di interi sottosistemi) del sistema da implementare. I diagrammi di interazione descrivono le
dinamiche del sistema.
diagrams
Classi di analisi
Le classi di analisi sono astrazione di entità del dominio del problema/soluzione usate per gestire i requisiti
funzionali (i requisiti non funzionali sono gestiti nella progettazione dell'architettura). Ogni classe di analisi
incarna un piccolo insieme ben definito di responsabilità e, in genere, sono classi semplici, comprensibili,
estendibili e adattabili. Le classi di analisi sono rappresentate con i diagrammi delle classi e, di solito, sono
rappresentate attraverso gli stereotipi di robustezza (boundary, control e entity).
Categorie delle classi di analisi
Le classi di analisi sono divise in diverse categorie: entità esterne, elementi del dominio delle informazioni,
eventi, ruoli delle persone, unità organizzative, luoghi e strutture.
Le entità esterne sono entità che producono o consumano informazioni a un sistema informatico, ad
esempio, altri sistemi, dispositivi, persone.
Gli elementi sono entità che fanno parte del dominio delle informazioni per il problema, ad esempio, rapporti,
display, lettere, segnali.
Gli eventi indicano delle azioni/operazioni che si verificano nel contesto del funzionamento del sistema, ad
esempio, un trasferimento di proprietà o il completamento di una serie di movimenti del robot.
I ruoli indicano i compiti delle persone che interagiscono con il sistema, ad esempio, manager, ingegnere,
venditore.

desione erpo, sue indicano le struture funzionali e divisionali ilevanti per una plicazione, ad esempio,
1 ludei malachini contesto del problema e la funzione complessiva del sistema, ad esempio, piano di
Le strutture definiscono classi di oggetti o classi di oggetti correlate, ad esempio, sensori, veicoli a quattro
ruote, computer
Tecniche di individuazione delle classi
istono diversi tipi di tecniche di individuazione delle classi: analisi nomi - verbi, approccio basato sui casi
so, approccio basato sui modelli di classi comuni, approccio basato sui modelli delle classi, responsabilità
collaborazioni (CRC) e approccio misto.
Analisi nome - verbo
L'analisi nomi - verbi utilizza i documenti di specifica dei requisiti, usa euristiche per identificare le classi e
loro caratteristiche, individua nomi e frasi verbali e si basa sulla completezza e correttezza d
nure so de roguit. a ultà dipende dallo stile di critura e un po anche della quantità di nomi
Componente del
Modello del
testo
Componente
nome proprio
Istanza
nome commune
classe
verbo di fare
metodo
verbo di classicazione eredità
verbo possessive
aggregazione
verbo modale
vincolo
aEsettivo
attributo
verbo transitivo
metodo
verbo intransitivo
metodo (evento) |
Esempio
Jim Smith
giocattolo, bambola
comprare, consigliare
è un
ha un
deve essere
di tre anni
entra, modifica
dipende da
Approccio guidato dai casi di uso
E simile all'analisi dei nomi e dei verbi e la applica agli scenari dei casi di uso. Si basa sull'identificazione degli
scenari chiave, delle interazioni tra gli attori e il sistema e si basa sulla completezza e correttezza. Aiuta a
garantire che il sistema soddisfi le esigenze degli utenti e che le interazioni tra i componenti siano ben definite
ed efficienti.
Modelli di classi comuni
I modelli di classi comuni utilizzano la teoria della classificazione generica degli oggetti, questa teoria fa parte
4

• Classe concettuale
• e.g. Prenotazione
• Classe di eventi
• e.g. Arrivo
• Classe organizzativa
• e.g. Agenzia di viaggio
• Classe persone
• e.g. Passeggero
• Classe di luoghi
• e.g. Ufficio
• Bahrami (1999)|
• Classe fisica
• e.g. Aereo
• Business class
• e.g. Prenotazione
• Classe logica
* e.g. Orario dei voli
• Classe di applicazione
* e g. Transazione per
Prenotazione
• Classe informatica
• e.g. Indice
• Classe comportamentale
• e.g. Annulla Prenotazione
• Rumbaugh et. Al. (1999)|
Classi, responsabilità e collaborazioni (CRC)
I modelli CRC si basano sull'utilizzo di schede a tre scomparti che identificano: il nome di una classe, le
responsabilità della classe (i.e., the funzionalità che fornisce) e le classi che hanno collaborazioni con la classe
corrente.
Le attività di analisi si basano su specifiche sessioni di brainstorming. Di solito si inizia ad esaminare i casi di
uso, si controllano le associazioni e le generalizzazioni, si identifica la mancanza di alcune classi necessarie o
almeno utili e, infine, si individuano le opportunità di migliorare le classi e le relazioni tra classi con delle
attività di refactoring. Il modello CRC non fornisce un processo sistematico per trovare classi complete e
affidabili, ma è un mezzo per la convalida dei requisiti identificando errori e omissioni.
Due importanti problemi che possono ridurre la qualità di un sistema sono: l'assegnamento di troppe
responsabilità ad una classe e la presenza di troppi collaboratori di una classe. Infatti, troppe responsabilità
rendono una classe poco coesa e si consiglia di assegnare a una classe al massimo tre o quattro responsabilità.
Se le responsabilità sono maggiori si consiglia di dividere le responsabilità su più classi. Se una classe o un
componente ha troppi collaboratori, Il problema è l'alto accoppiamento tra le classi e/o i componenti. Infatti,
elementi altamente accoppiati sono difficili da riutilizzare in altri progetti e rendono il software più complesso
e difficile da comprendere. Come per il caso della coesione, la soluzione è realizzare una corretta divisione
delle responsabilità di classi e componenti. La figura qui sotto fornisce una semplice descrizione grafica
dell'identificazione delle classi e delle sue parti.

Approccio Misto
Spesso per cercare di migliore le prestazioni, si prova a combinare l'uso di diverse tecniche. Ad esempio, un
approccio molto utilizzato è il seguente: Si identificano le classi iniziali attraverso la conoscenza del dominio
applicativo e del problema, quindi si individuano delle classi in base a dei modelli di classe comuni e si usa
l'analisi nome verbo per aggiungere ulteriori classi, si usano i casi di uso per verificare la scelta delle classi e
si conclude con i brainstorming dei modelli CRC.
Errori Comuni di Analisi
In certi casi, l'analisi non è applicata al meglio tra i risultati sono presenti degli errori e dei difetti. In
particolare, spesso i nomi sono controintuitivi o incomprensibili, vengono assegnate le molteplicità alle
associazioni anche se non c'è nessuna sicurezza che saranno i valori finali, si cerca di risolvere i problemi di
implementazione e, infine si cerca di ottimizzare il software per il riutilizzo prima di controllare la correttezza
dei casi di uso.
Diagramma delle Classi: Descrizione di un appartamento
- Un appartamento è composto da una o più stanze
- Ogni stanza ha una lunghezza e una larghezza
L'appartamento è posseduto da uno o più persone
- Il palazzo che contiene l'appartamento ha un certo numero di piani
- Ed è composto da uno o più appartamenti |
Diagramma delle Classi: Prenotazioni Online
Un servizio di prenotazione on line di stanze di albergo mantiene le informazioni sugli alberghi a disposizione
(nome dell'albergo, indirizzo, telefono, località, numero di stanze, numero di stelle) e le sue stanze (numero
camera, tipo di stanza, e l'utente che la sta occupando).
Inoltre, il sistema mantiene le informazioni sugli utenti registrati (nome, cognome, codice fiscale, età,
indirizzo, telefono, località, email e password) e lo storico dei suoi soggiorni (nome dell'albergo, numero di
stanza, costo, data di arrivo e data di partenza).
Un servizio di prenotazione on line di stanze di albergo mantiene le informazioni sugli alberghi a disposizione

Stay
hotel. Sting F)
a - chediout: EDute [
G BockingSyster
Diagramma delle Classi: Offerta formativa di una Università
- Una università offre diversi percorsi formativi
Il completamento di un percorso porta al conseguimento di un titolo di riconoscimento
Ogni titolo di riconoscimento è pubblicizzato tramite un sito online dell'Università
Ogni percorso comprende differenti moduli
Gli studenti di un percorso seguono fino a 8 moduli
Gli studenti si possono iscriversi a uno o a due percorsi
Per ogni percorso completato viene assegnato un titolo
https://app.diagrams.net/

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L8-Scenari e casi di uso (dispensa)
Prof. Agostino Poggi
A.A. 2023/2024
1

Storie e scenari
Le storie e gli scenari degli utenti sono esempi di vita reale di come un sistema può essere utilizzato. Le storie
degli utenti sono descrizioni generali e informali che descrivono un sistema o una parte di un sistema dal
punto di vista dell'utente. Gli scenari sono forme strutturate di storie utente. Uno scenario comprende: una
descrizione della situazione di partenza, una descrizione del normale flusso degli eventi, una descrizione di
ciò che può andare storto, la disponibilità di informazioni su altre attività concorrente e, infine, una
descrizione dello stato al termine dello scenario. Gli stakeholder possono commentare gli aspetti positivi e
negativi di ciò che è stato introdotto nella storia/scenario.
Casi di uso
Sono tecniche per scoprire, chiarificare e concordare i requisiti di un sistema. I casi di uso vanno non vanno
sempre bene per descrivere i requisiti e le funzionalità di un sistema. In particolare, i casi di uso vanno bene
per descrivere le modalità di utilizzo di un sistema che: esegue interazioni significative, tipo operativo e
strutturato, con gli attori del sistema. Inoltre, i casi di uso descrivono come eseguire le attività del sistema e
dovrebbero descrivere tutte le possibili interazioni tra gli attori e il sistema. Inoltre, un caso di uso ha un unico
attore iniziatore, il suo comportamento è definito tramite la descrizione dei passi dell'attività (fino a 5, ma
spesso sono di più), non includono scelte di implementazione e includono le principali eccezioni aziendali e
la loro gestione. La descrizione di caso di uso può essere integrata con dei diagrammi UML
Un caso di uso non è mappato uno a uno ai requisiti, ma ogni requisito deve essere coperto da almeno un
caso di uso e ogni caso di uso può contenere molti requisiti. I casi di uso sono descritti combinando del
diagrammi dei casi di uso, delle descrizioni testuali e opzionalmente dei diagrammi di interazione.
Ranking dei casi di uso
Il ranking dei diversi casi di uso è in genere espresso con valori qualitativi. Ad esempio: alto, medio e basso,
o deve avere, essenziale e bello da avere.
L'ordine di importanza dei casi di uso dipende da diversi fattori:
- Il peso dell'Impatto sulla progettazione dell'architettura
- L'Inclusione di funzioni rischiose, critiche in termini di tempo o complesse
Il coinvolgimento di ricerche significative e/o tecnologie nuove e rischiose
- La descrizione dei processi principali della linea di business
La tabella qui sotto descrive i ruoli necessari per descrivere i casi di uso, i diversi casi di uso da definire, la
priorità dei casi di uso: H (high), L (low) e M (medium), e gli eventuali sotto-caso d'uso.
Une Case
Course karning
1.1 H
12H
Course Discusice
22L
23 L
3.1. н|
99 g
Repistered teacher
Counse
4 MI
12 M
5.1 (M]
System administrat

Operazioni principali dei casi di uso
- Le operazione principali dei casi di uso sono cosi ordinate:
Definire lo stato iniziale e le precondizioni
Definire quando inizia il caso di uso
Definire l'ordine delle attività nel flusso principale di eventi
Definire eventuali flussi alternativi di eventi
Definire eventuali flussi eccezionali di eventi
Detinire eventuali post-condizioni e lo stato finale
Menziona gli attori coinvolti in questo caso di uso e tutti i casi di uso utilizzati o estesi da questo caso
di uso
Menzionare i relativi diagrammi ci interazione
- Menzionare eventuali problemi di progettazione in un appendice
Guide per lo sviluppo dei casi di uso
Per sviluppare dei casi di uso di buona qualità, sono consigliate le seguenti azioni:
- Non pensare al modo in cui verrà implementato
cerca di essere il piu narrativo possioulel
- Individua gli scenari di successo dello stato
- Introduci tutti i possibili scenari di un caso di uso
Concorda con i colleghi uno "stile di formato" per la descrizione del caso di uso
- Usa un nome appropriato per i verbi che devi usare nella descrizione del caso di uso
- Gestisci le eccezioni del documento le ramificazione e le sequenze alternative
- Non rappresentare i singoli passi come casi di uso
Casi di Uso - Un Negozio di Vendita Online
L'obiettivo è realizzare un diagramma dei casi di uso che descriva le entità e le attività di un negozio che
fornisce un catalogo on-line per l'acquisto di prodotti. In particolare, la descrizione è definita attraverso alcuni
semplici frasi: l'amministratore del negozio ha il compito di aggiornare il catalogo online e ogni cliente può
esaminare il catalogo e acquistare un prodotto inserendo i dati di pagamento. Se il cliente non è già registrato,
allora prima di poter acquistare un prodotto deve registrare il suo account. Se il cliente acquista un prodotto,
allora il sistema genera l'ordine e lo invia al reparto ordini che lo evade.
In particolare, in questo semplice esempio gli attori sono: l'amministratori del negozio, il cliente e il reparto
ordini. Le funzionalità sonno: organizzare il catalogo, consultare il catalogo, effettuare acquisti e generare ed
evadere gli ordini. La figura qui sotto rappresenta il relativo diagramma dei casi di uso.

Genera cron
edel
todica catalogl
Casi di uso - Un altro negozio di vendita online
Vediamo come costruire una descrizione di un altro negozio di vendita online. Questa descrizione è un po'
più completa e, oltre al flusso principale, introduce alcuni flussi alternativi.
Anche in questo caso, la descrizione è definita attraverso alcuni semplici frasi: gli utenti devono registrarsi
per accedere al catalogo e fare degli acquisti.
In particolare, per fare l'acquisto, devono inviare un ordine di acquisto contenente l'indirizzo di consegna, il
codice del prodotto e i dati di pagamento.
L'ordine verrà ricevuto da un impiegato del negozio che invierà il prodotto al compratore.
Un impiegato ha il ruolo di amministratore e ha il compito di tenere aggiornato il catalogo.
Descrizione del Caso di Uso: Inserisci l'Ordine
Anche in questo caso, la descrizione è definita attraverso alcuni semplici frasi: l'utente ha selezionato gli
articoli da acquistare e quindi ordina gli articoli, l'utente fornirà le informazioni di pagamento e spedizione,
il sistema risponderà con la conferma dell'ordine e un numero di tracciamento che l'utente potrà utilizzare
per verificare lo stato dell'ordine, il sistema sfrutta il sistema di evasione ordini per fornire all'utente una data
di consegna stimata per l'ordine, che includerà tutti gli articoli selezionati, il sistema sfrutta il sistema di
fatturazione per consentire il pagamento dell'utente e, infine, l'utente potrebbe già avere un account con
l'azienda con informazioni di fatturazione e spedizione.
Place Oron
Diagramma del Caso di Uso: Inserisci l'Ordine

Attori, Trigger, Pre e Post - Condizioni
Gli attori del caso di uso sono: un utente, il sistema di adempimento e il sistema di fatturazione.
Il trigger, cioè il comando che fa partire le attività, è individuato dalla seguente frase: l'utente indica che
desidera acquistare gli articoli che ha selezionato.
La pre-condizione che deve essere vera per far partire le attività è individuato dalla seguente frase: l'utente
ha selezionato gli articoli da acquistare. La post-condizione che deve essere vera alla conclusione del caso di
uso è definita dal fatto che: l'ordine è stato inserito nel sistema, l'utente ha ricevuto un ID di tracciamento
per l'ordine e, infine, l'utente ha ricevuto la data di consegna prevista per l'ordine.
Flusso Principale
L'utente indicherà che desidera ordinare gli articoli che sono già stati selezionati
2. Il sistema presenterà le informazioni di fatturazione e spedizione che l'utente ha precedentemente
memorizzato
3. L'utente confermerà che le informazioni di fatturazione e spedizione esistenti devono essere
utilizzate per questo ordine
Il sistema presenterà l'importo dell'ordine, comprese le tasse applicabili e le spese di spedizione
L'utente confermerà che le informazioni sull'ordine sono corrette
Il sistema fornirà all'utente un ID di tracciamento per l'ordine
7. Il sistema invierà l'ordine al sistema di evasione ordini per la valutazione
8. Il sistema di evasione ordini fornirà al sistema una data di consegna stimata
9. Il sistema presenterà all'utente la data di consegna stimata
10. L'utente indicherà che l'ordine deve essere effettuato
11. Il sistema richiederà che il sistema di fatturazione addebiti all'utente l'ordine
12. Il sistema di fatturazione confermerà che l'addebito è stato effettuato per l'ordine
13. Il sistema invierà l'ordine al sistema di evasione ordini per l'elaborazione
14. Il sistema di evasione ordini confermerà che l'ordine è in fase di elaborazione
15. Il sistema indicherà all'utente che le è stato addebitato la spesa dell'ordine
16. Il sistema indicherà all'utente che l'ordine è stato effettuato
17. L'utente uscirà dal sistema
Flusso Alternativo 1
R1: L'utente desidera utilizzare informazioni di spedizione e fatturazione diverse da quelle memorizzate nel
suo accounti
1. L'utente indicherà che questo ordine deve utilizzare informazioni di fatturazione o spedizione
alternative
2. L'utente inserirà le informazioni di fatturazione e spedizione per questo ordine
3. Il sistema convaliderà le informazioni di fatturazione e spedizione
4. Il caso di uso torna al passo 4 del flusso normale
Flusso Alternativo 2
R2: L'utente scoprirà un errore nelle informazioni di fatturazione o spedizione associate al proprio account
e le modificherà

L'utente indicherà che i dati di fatturazione e spedizione non sono corretti
L'utente moditicherà le informazioni di fatturazione e spedizione associate al proprio account
3.
lIl sistema convalidera le intormazioni di fatturazione e spedizione.
Il caso di uso torna al passo 4 del fiusso normale
Flusso Alternativo 3
R3: L'utente determinerà che l'ordine non è accettabile (forse a causa di insoddisfazione per la data di
consegna stimata) e annullerà l'ordine
Lutente richiederal annullamento dell'ordine
Il sistema confermerà che l'ordine è stato annullato
Il caso di uso è concluso
Template per i casi di uso

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L9-Elementi di progettazione (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Processo di Progettazione
Il processo di progettazione ha obiettivo di capire come implementare il sistema. Questa attività si basa sulla
documentazione dei requisiti e sui principi generali di progettazione. L'obiettivo è un modello su cui si può
ragionare e quindi che in seguito potrebbe guidare.
Come primo passo si guarda il problema da diverse angolazioni per scoprire i requisiti di progettazione e si
cerca di identificare una o più soluzioni, si valutano le soluzioni e si sceglie quella più opportuna in base
all'esperienza del progettista e alle risorse disponibili.
Quindi, si realizzano delle astrazioni della soluzione e si descrivono queste astrazioni utilizzando notazioni
grafiche, formali o altre notazioni descrittive per descrivere i componenti del progetto.
Infine, questo processo viene ripetitivo, per ciascuna astrazione identificata finché il progetto non viene
espresso in termini primitivi.
Il sistema dovrebbe avere un'organizzazione modulare che fa un uso intelligente del controllo tra i
componenti. Dovrebbe implementare tutti i requisiti espliciti contenuti nel modello di analisi e deve
soddisfare tutti i requisiti impliciti desiderati dal cliente. Dovrebbe essere una guida leggibile e comprensibile
per chi genera codice e per chi testa e successivamente supporta il software e dovrebbe fornire un quadro
completo del software, illustrando dati, funzionali e comportamenti che dovrebbe utilizzare il nuovo sistema
dal punto di vista dell'implementazione.
Concetti e Principi di Progettazione
Alcuni concetti di progettazione, come l'astrazione, il raffinamento e l'information hiding sono ben noti alle
persone che si occupano dell'ingegneria del software. Altri concetti, come la modularità, la coesione e
l'accoppiamento, sono sicuramente meno conosciuti, altri, come i principi di progettazione, sono ancora
meno conosciuti. Tuttavia, la loro conoscenza è molto importante per progettare e sviluppare sistemi di
buona qualità.
Modularità
Questi La modularità si basa sull'uso di unità linguistiche modulari (ad esempio, l'uso di package e moduli
Java) la presenza di poche, piccole ed esplicite interfacce e sull'information hiding. Ogni modulo dovrebbe
comunicare con il minor numero possibile di altri moduli. Se due moduli qualsiasi comunicano, dovrebbero
scambiarsi la minor quantità di informazioni possibili. Inoltre, se due moduli qualsiasi comunicano, ciò deve
essere ovvio, ad esempio, deve essere descritto nella documentazione di progettazione. Tutte le informazioni
su un modulo dovrebbero essere private a meno che non sia specificatamente dichiarato diversamente. Le
interfacce sono i mezzi per l'accesso alle informazioni del modulo.
L'idea di base della modularità consiste nel fatto che i moduli o componenti possono essere combinati tra
loro in un sistema con facilità. Una gestione corretta della modularità permette di ridurre la complessità,
facilitare il cambiamento, l'implementazione e lo sviluppo parallelo. I componenti modulari sono progettati
per essere utilizzati indipendentemente o come parti di un unico sistema integrato. Un metodo di
progettazione può dirsi modulare solo se supporta scomponibilità, componibilità, comprensibilità, continuità
e protezione.
La scomponibilità modulare si basa sul fatto che un problema software può essere suddiviso in un piccolo
numero di sotto-problemi meno complessi, collegati da una struttura semplice e sufficientemente
indipendenti da permettere di lavorare separatamente su ciascun elemento.

La componibilità modulare si basa sul fatto che degli elementi software possono essere combinati tra loro
per produrre dei nuovi sistemi anche in ambienti diversi da quello in cui sono stati inizialmente sviluppati.
La comprensibilità modulare è soddisfatta se, in genere, una persona può comprendere ogni modulo senza
dover conoscere gli altri o dovendone esaminare solo alcuni moduli.
La continuità modulare è soddisfatta, se una piccola modifica nella specifica del problema attiverà la modifica
di un solo modulo o di un numero limitato di moduli.
Infine, la protezione modulare è soddisfatta, se l'effetto di una condizione anomala che si verifica in fase di
esecuzione in un modulo rimarrà confinato a quel modulo o si propagherà solo ad alcuni moduli vicini.
Difficoltà ad Individuare la Migliore Modularità
La progettazione modulare del software può essere brevemente descritta come la suddivisione di un sistema
software in più parti (moduli) autonome e ben isolate, liberamente accoppiate tra loro. La progettazione di
software modulare è uno standard di riferimento per la progettazione di software mantenibile. Ma per usarlo
correttamente, dovresti conoscerne i costi e i gli eventuali compromessi di implementazione. La modularità
e il basso accoppiamento rendono più semplice comprendere ciascun modulo isolatamente, ma potrebbe
essere più difficile comprendere l'intero sistema e quindi poter fare una buona previsione sui costi.
of modules
Coesione
La coesione misura la vicinanza delle relazioni tra elementi di un componente o modulo di un sistema. Una
forte coesione è auspicabile perché semplifica: la correzione, il cambiamento e l'estensione, riduce i test e
promuove il riutilizzo. In genere la qualità della coesione e descritta attraverso l'identificazione di una
sequenza di livelli che parte dal livello peggiore al livello migliore di coesione. Questi livelli sono in ordine:
coesione casuale, coesione logica, coesione temporale, coesione procedurale, coesione comunicativa,
coesione sequenziale, coesione funzionale e coesione dell'oggetto.
Con la coesione casuale gli elementi non sono correlati, ma semplicemente raggruppati per comodità.
Con la coesione logica gli elementi che svolgono funzioni simili (ad esempio, hanno un input e una gestione
degli errori simili).
Con la coesione temporale gli elementi che si attivano in un momento comune, hanno un avvio e uno
spegnimento comuni.
Con la coesione procedurale gli elementi costituiscono un'unica sequenza di controllo.
Con la coesione comunicativa gli elementi operano sullo stesso input o producono lo stesso output.
Con la coesione sequenziale gli elementi operano in sequenza su dati condivisi (ad esempio, l'output di un
elemento è input per un altro).
Con la coesione funzionale gli elementi sono dedicati al raggiungimento di un unico requisito funzionale.
4

Con la coesione dell'oggetto solo le operazioni sugli oggetti consentono di modificare o ispezionare gli
attributi dell'oggetto (information hiding).
Accoppiamento
Per accoppiamento si intende il grado con cui ciascuna componente di un software dipende dagli altri
componenti. Un basso grado di accoppiamento è spesso sinonimo di un sistema ben strutturato e ben
progettato. Un elevato accoppiamento può portare a diversi problemi. Infatti, i moduli altamente accoppiati
sono difficili da riutilizzare in altri progetti e rendono il software più complesso e difficile da comprendere.
Con nessun accoppiamento non c'è nessuna interazione tra i moduli e quindi non ha nessuna utilità (i moduli
non hanno nessuna possibilità di interagire). In particolare, con un accoppiamento debole, i moduli sono
fortemente indipendenti e con un accoppiamento forte, i moduli sono fortemente dipendenti gli uni dagli
altri. Anche la qualità dell'accoppiamento è descritta attraverso l'identificazione di una sequenza di livelli
che, tuttavia sono ordinati in ordine inverso; si parte dal livello migliore di al livello peggiore di
accoppiamento. Questi livelli sono in ordine: diretto, dati, stamp, controllo, esterno, comune, precoce e
contenuto.
Con nessun accoppiamento diretto, ovviamente non c'è nessuna dipendenza.
Con l'accoppiamento dati, solo i dati necessari vengono passati come argomenti.
Con l'accoppiamento stamp (struttura dati), le strutture dati vengono passate come una lista di elementi che
viene utilizzati solo in parte.
Con l'accoppiamento di controllo, vengono passati flag e altri parametri.
Con l'accoppiamento esterno, si creano dei legami con dispositivi e/o driver di dispositivi.
Con l'accoppiamento comune, si usano delle variabili globali.
Con l'accoppiamento precoce, si usano dei numeri e altri valori in un programma,
Con l'accoppiamento contenuto, si modificano le istruzioni/dati di un altro modulo o si dirama al centro di
un modulo.
In generale, l'accoppiamento in genere dovrebbe essere basso. Infatti, generalmente più veloce per costruire
e mantenere i sistemi, ma un basso accoppiamento può comportare maggiori costi di prestazione, mentre
un alto accoppiamento può permettere di migliorare le prestazioni del sistema. Tuttavia, un alto
accoppiamento crea molti più problemi: i componenti sono difficili da comprendere isolatamente, 1
cambiamenti nei componenti si propagano ad altri componenti e i componenti sono difficili da riutilizzare.

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L9-Progettazione architetturale (dispensa)
Prof. Agostino Poggi
A.A. 2023/2024
1

Scopo della Progettazione Architetturale
Si occupa di comprendere come dovrebbe essere organizzato un sistema software e di progettare la struttura
complessiva di quel sistema. È il collegamento critico tra progettazione e ingegneria dei requisiti, poiché deve
identificare i principali componenti strutturali di un sistema e le relazioni tra loro. L'output del processo di
progettazione architetturale è un modello dell'architettura che descrive come il sistema è organizzato con
un insieme di componenti comunicanti.
Requisiti e Progettazione
In linea di principio, i requisiti dovrebbero indicare cosa dovrebbe fare il sistema e la progettazione
dovrebbe descrivere come lo fa. In pratica, requisiti e progettazione sono inseparabili. E possibile
progettare un'architettura di sistema per strutturare i requisiti. Il sistema può interagire con altri sistemi
che generano requisiti di progettazione. L'uso di un'architettura specifica per soddisfare requisiti non
funzionali può essere un requisito di dominio.
Diagrammi a Blocchi
I diagrammi a blocchi sono molto semplici e mostrano le entità e le relazioni che definiscono l'architettura.
Sono il metodo più utilizzato per documentare le architetture software, ma sono molto astratti. I diagrammi
国］
a blocchi sono stati criticati perché mancano di semantica, non mostrano i tipi di relazioni tra le entità e le
proprietà visibili delle entità nell'architettura. Tuttavia, sono utili per la comunicazione con le parti
interessate e per la pianificazione del progetto. Un diagramma ancora più semplice è il diagramma a scatole
e linee. Questo diagramma viene illustrato nella figura qui sotto; in particolare, le "scatole" indicano gli
elementi dell'architettura e le linee le relazioni tra i suoi elementi.
Astrazione Architetturale
Si occupa dell'architettura delle singole parti e del modo in cui un sistema viene scomposto in componenti
In generale si occupa dell'architettura di sistemi complessi che includono i componenti del sistema e altri
sistemi
Questi sistemi possono essere distribuiti su nodi di calcolo differenti, che possono essere posseduti e gestiti
da società diverse.
Progettazione dell'Architettura e Riuso
La progettazione architetturale è un processo creativo quindi il processo differisce a seconda del tipo di
sistema che si sta sviluppando. uttavia, tutti i processi di progettazione affrontano una serie di decisioni

comuni che influenzano le caratteristiche non funzionali del sistema. I sistemi nello stesso dominio hanno
spesso architetture simili che riflettono i concetti di dominio.
Le linee di prodotti applicativi sono costruite attorno a un'architettura principale con varianti che soddisfano
particolari esigenze dei clienti. L'architettura di un sistema può essere progettata attorno a uno o più modelli
o stili architetturali. Questi modelli catturano l'essenza di un'architettura e possono essere istanziati in diversi
modi.
Pattern Architetturali
I pattern
Delle
un mezzo per rappresentare, condividere e riutilizzare la conoscenza.
Un modello
architetturale è una descrizione stilizzata di una buona pratica di progettazione, che è stata provata e testata
in diversi ambienti. il modelli dovrebbero includere informazioni su quando sono utili e quando non sono
utili. I modelli possono essere rappresentati utilizzando descrizioni tabellari e grafiche.
Architettura - Model-View-Controller (MVC) |
È un sistema basato su tre componenti principali: modello, vista e controllore. Il modello contiene i dati e
fornisce metodi per accedere ai dati. La vista visualizza il contenuto del modello e si aggiorna quando il
modello cambia; inoltre, il sistema può fornire diverse visualizzazioni. Infine, il controllore gestisce le
interazioni dell'utente e le traduce in operazioni nel modello. In particolare, il modello MVC è usato quando
esistono più modi per visualizzare e interagire con i dati e permette di modificare le rappresentazioni dei dati
in modo indipendente. Lo svantaggio è dovuto alla necessità di scrivere un software complesso che richiede
un gran numero righe di codice.
Architettura - Layered
Questo modello organizza il sistema in livelli e ogni livello fornisce servizi al livello superiore. Inoltre, quando
l'interfaccia di un livello cambia, solo i servizi del livello superiore dovranno essere eventualmente aggiornati.
I livelli più bassi rappresentano i servizi principali che in genere verranno utilizzati in tutto il sistema. Nuovi
livelli possono essere aggiunti. Questo tipo di modello è utilizzato :quando si costruiscono nuove strutture
sopra i sistemi esistenti, quando lo sviluppo è distribuito su più team e quando è richiesto un sicurezza
multilivello. I vantaggi di questo modello è vantaggioso quando: è richiesta un sicurezza multilivello e perché
lo sviluppo dei livelli può essere sviluppato in parallelo da più team. Gli svantaggi sono la difficoltà ad avere
una netta separazione tra i livelli e la bassa qualità delle prestazioni.
Architettura - Repository
Questo modello ha lo scopo di gestire delle grandi quantità di dati in un database o repository centrale e
permettere a dei sottosistemi. In particolare, i sottosistemi non interagiscono direttamente, ma solo
attraverso il repository. Quando è necessario condividere grandi quantità di dati, il modello di condivisione
del repository è il più comunemente utilizzato e garantisce una condivisione dei dati efficiente. Questo
modello è principalmente utilizzato quando vengono generati grandi volumi di informazioni che devono
essere archiviati per un lungo periodo e quando l'inclusione dei dati nel repository attiva un'azione o uno
strumento. I vantaggi dell'uso di questo modello sono: i sottosistemi possono interagire in modo
indipendente dagli altri sottosistemi, e la propagazione delle modifiche dei dati è semplice. Gli svantaggi
sono: il repository è il "collo di bottiglia" del sistema e le prestazioni dipendano dal suo funzionamento, la
comunicazione tra i sottosistemi è inefficiente visto che deve passare attraverso il repositori: il repository
riceve una richiesta da un sottosistema "chiamante" e la propaga a un sottosistema "destinazione". La
gestione dei dati tramite la loro distribuzione su più nodi di gestione dei dati è molto difficile.

Architettura • ripe & rinter
@vesta architettura si basa su entita indicendent chiamate tilter (mitri che esecuono trastormazioni sui dati
ed elaborano l'input che ricevono, e dei connettori (pipe) che gestiscono il flusso di dati da trastormare. I dati
fluiscono in una direzione. Inizia da un'origine dati, arriva alle porte di input di un filtro dove l'elaborazione
viene eseguita nel componente, quindi viene passato attraverso le sue porte di outout attraverso una pipe a
filtro successivo e intine termina al destinazione del dati. Un singolo filtro puo consumare dati da o produrre
dati verso una o piu porte. Queste operazioni possono anche essere eseguiti contemporaneamente e non
sono dipendenti. L'output di un filtro è l'input di un altro, quindi l'ordine è molto importante. Una pipe ha
un'unica sorgente per il suo input e una singola destinazione per il suo output. Conserva la sequenza dei dati
e non altera il passaggio dei dati. I vantaggi dell'uso di questo modello sono: garantisce un accoppiamento
libero e flessibile di componenti e filtri, consente di sostituire i filtri senza modificare gli altri filtri, la
produzione di dati verso una o più porte permette un'elaborazione parallela, ovviamente tramite i filtri, I filtri
possono essere trattati come scatole nere. Gli utenti del sistema non hanno bisogno di conoscere la logica
dietro il funzionamento di ciascun filtro, I filtri sono riutilizzabili e quindi ogni filtro può essere richiamato e
utilizzato più e più volte. Gli svantaggi sono: la presenza di un gran numero di filtri può ridurre le prestazioni
a causa di eccessivi costi di calcolo, spesso non sono adatti per calcoli di lunga durata, è difficile individuare
gli errori di esecuzione, e non è adatto per sistemi interattivi.

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L10-Principi di progettazione (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Principi di Progettazione Orientata agli Oggetti
Alcuni ricercatori hanno individuato alcuni principi che possono aiutare a realizzare software di buona
qualità. Questi principi sono: SRP - Principio della responsabilità unica, OCP - Principio aperto-chiuso, LSP
Principio di sostituzione di Liskov - ISP: Principio di segregazione delle interfacce e DIP: Principio di inversione
delle dipendenze.
Principio della Responsabilità Unica
Il principio della responsabilità unica afferma che una classe dovrebbe avere un solo motivo per cambiare.
Infatti, le modifiche ai requisiti in genere si associano alle responsabilità e con maggiori responsabilità ci sono
maggiori probabilità di cambiamento; inoltre, avere più responsabilità all'interno di una classe unisce queste
responsabilità. Quindi, più classi vengono interessate da una modifica, maggiore è la probabilità che la
modifica introduca errori. Per questo motivo il principio della responsabilità unica suggerisce che avere molte
classi piccole con responsabilità distinte danno luogo a una progettazione più flessibile.
Principio Aperto-Chiuso
Il principio aperto-chiuso afferma che un modulo o un componente deve essere aperto per l'estensione, ma
chiuso per la modifica. Quindi si approva che una classe può essere estesa, ad esempio, aggiungendo nuovi
comportamenti senza aver necessità di fare delle modifiche alla classe, e si ricorda che ogni nuova modifica
può introdurre bug e richiedere del lavoro aggiuntivo. Quindi se si vuole modificare una classe per
aggiungere, ad esempio, nuove funzionalità, è sicuramente meglio inserire delle nuove classi che possano
implementare queste nuove funzionalità, visto che con questa soluzione si ha meno probabilità di introdurre
dei problemi ed errori.
Principio di Sostituzione di Liskov
Il principio di sostituzione di Liskov afferma che le sottoclassi dovrebbero essere sostituibili con le loro classi
base. Infatti, le classi derivate devono onorare i contratti delle loro classi base e possono eventualmente
estendere la classe senza sostituire la funzionalità delle classi base. Se ciò non avviene, le classi derivate
possono produrre effetti indesiderati (e.g., i comportamento dei metodi della classe e i metodi delle classi
derivate sono differenti).
Principio di Segregazione delle Interfacce
Il principio di segregazione delle interfacce afferma che avere molte interfacce specifiche con un numero
limitato di metodi è meglio di avere un'unica interfaccia con molti metodi. Questa soluzione permette di
mantenere le interfacce snelle e mirate e di evitare di dover dipendere da cose non necessarie (e.g., la
necessità di implementare dei metodi dell'interfaccia non necessari per gran parte delle classi e componenti
che si devono implementare). Quindi se si vuole evitare questo problema, bisogna effettuare il refactoring
delle interfacce con un gran numero di metodi in modo che generare un maggior numero di interfacce con
un numero limitato di metodi.
Principio di Inversione delle Dipendenze
Il principio di Inversione delle Dipendenze afferma che i moduli di alto livello non dovrebbero dipendere dai
moduli di basso livello e che i moduli di alto e basso livello dovrebbero dipendere da astrazioni. Inoltre, le
astrazioni non dovrebbero dipendere dai dettagli e i dettagli dovrebbero dipendere dalle astrazioni. Inoltre,
si dice che, in genere, gli elementi astratti (e.g., le interfacce) sono stabili (poche probabilità di modifiche)
mentre gli elementi concreti (e.g., classi e componenti) sono instabili (molte probabilità di modifiche). Per
questo motivo bisogna evitare di derivare, associare o dipendere da classi o componenti concreti.
Principi di Coesione dei Package

Alcuni ricercatori hanno definito alcuni principi utili per la coesione dei package. Questi principi sono: REP: II
principio di equivalenza del riutilizzo del rilascio, CCP: Il principio di chiusura comune e CRP: Il principio del
riutilizzo comune.
Principio di Equivalenza del Riutilizzo del Rilascio
Il principio di equivalenza del riutilizzo del rilascio afferma il granello di riutilizzo è il granello di rilascio; nel
contesto dello sviluppo software, indica che il granulo di riutilizzo, un componente, non può essere più
piccolo del granulo di rilascio. Poiché la riusabilità deve essere basata sui componenti, i componenti
riutilizzabili
devono contenere classi riutilizzabili. Quindi, almeno alcuni componenti dovrebbero
comprendere insiemi di classi riutilizzabili. In conclusione, si può dire che tutte le classi di un package devono
essere riutilizzabili o non riutilizzabili e le classi non correlate allo scopo del package non devono essere
incluse. Infatti, un package costruito come una famiglia di classi riutilizzabili tende ad essere molto utile e
riutilizzabile.
Principio di Chiusura Comune
Il principio di chiusura comune afferma che le classi che cambiano insieme dovrebbero stare insieme,
permettendo di ridurre al minimo l'impatto del cambiamento per il programmatore. Infatti, le classi
dovrebbero esser inserite in base alla loro coesione e appartenere alla stessa area funzionale o
comportamentale. Con queste soluzioni queste classi diventano inseparabili e interdipendenti.
Principio Comune di Riutilizzo
Il principio comune di riutilizzo afferma che le classi che non vengono riutilizzate insieme non devono essere
raggruppate insieme e che le classi raggruppate insieme dovrebbero cambiare per gli stessi motivi. Questo
modo di procedere permette di evitare le dipendenze non necessarie.
Principi di Accoppiamento dei Package
Alcuni ricercatori hanno definito alcuni principi utili per la accoppiamento dei package. Questi principi sono:
ADP: Principio delle dipendenze acicliche, SDP: Principio delle dipendenze stabili eSAP: Principio delle
astrazioni stabili
Principio delle Dipendenze Acicliche
Il principio delle dipendenze acicliche afferma che non bisogna consentire cicli nel grafo delle dipendenze.
Infatti, in certe situazioni, un problema che si presenta per un team o un programmatore bloccando la sua
attività di sviluppo di un task potrebbe bloccare l'attività degli altri team o programmatori. Se non ci sono
cicli, non ci dovrebbero essere interferenze con gli altri team o con gli altri programmatori.
Principio delle Dipendenze Stabili
Il principio delle dipendenze stabili afferma che le dipendenze tra i componenti di un progetto dovrebbero
essere nella direzione della stabilità e quindi un componente dovrebbe dipendere solo da componenti che
sono più stabili di esso. Infatti, ogni volta che un package cambia, tutti i package che dipendono da esso
devono essere convalidati per garantire che funzionino come previsto dopo la modifica. Quindi, maggiore è
il numero di package che dipendono da un package instabile, maggiore sarà il disagio ogni volta che cambia.
Principio delle Astrazioni Stabili
Il principio delle Astrazioni Stabili afferma che un package dovrebbe essere tanto astratto quanto stabile.
Inoltre, si dice che i package astratti dovrebbero essere responsabili e indipendenti (stabili - facili da cui
dipendere) e i package concreti dovrebbero essere irresponsabili e dipendenti (instabili - facili da cambiare).

Quindi un'architettura ideale dovrebbe avere la seguente struttura: un insieme di package instabili
(modificabili - collocati in alto) e un insieme di package stabili (difficili da cambiare - collocati sul fondo)
Buone Attività di Progettazione
Bisogna utilizzare la strategia dividi e conquista. Infatti, cercare di affrontare qualcosa di grande tutto in una
volta è normalmente molto più difficile che affrontare una serie di cose più piccole.
Bisogna aumentare la coesione ove possibile. Per fare ciò si dice che un sottosistema o modulo può avere
un'elevata coesione se tiene insieme solo le cose che sono correlate.
Bisogna ridurre l'accoppiamento ove possibile. L'accoppiamento avviene quando ci sono interdipendenze tra
un modulo e l'altro, e quindi è necessario mantenere il livello di astrazione il più alto possibile. Infatti, un'alta
astrazione garantisce che la progettazione consenta di nascondere o rinviare la considerazione dei dettagli,
riducendo così la complessità del sistema.
Bisogna aumentare la riusabilità ove possibile. In particolare, è necessario progettare i vari aspetti del
sistema in modo che una buona parte degli elementi possano essere riutilizzati in altri contesti.
Bisogna riutilizzare progetti e codici esistenti ove possibile. In particolare, la progettazione con il riuso è
complementare alla progettazione per la riusabilità.
Bisogna progettare per la flessibilità. In particolare, è necessario anticipare attivamente i cambiamenti che
un sistema potrebbe dover subire in futuro e prepararsi ad esso
Bisogna anticipare l'obsolescenza. In particolare, e necessario pianificare i cambiamenti delle tecnologie e/o
dell'ambiente in modo che il software possa essere facilmente modificato, se necessario, e quindi continui a
funzionare.
Bisogna progettare per la portabilità. In particolare, è necessario, tramite il refactoring delle parti del
software in cui è necessario, fare in modo che il software venga eseguito su quante più piattaforme possibile.
Bisogna progettare per la testabilità. In particolare, e necessario adottare misure per semplificare i test.
Bisogna progettare in modo difensivo. In particolare, non bisogna mai pensare che gli utenti usino un
dispositivo o un sistema nel modo indicato dalla documentazione o da una interazione con chi ha sviluppato
il dispositivo o il sistema, e non bisogna fidarsi mai di come gli altri cercheranno di utilizzare un componente.

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L11-Testing (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Testing di un programma
Il testing di un programma ha lo scopo di dimostrare che un programma fa quello che dovrebbe fare
dimostrando che il software soddisfa i suoi requisiti. Per garantire questo risultato, il testing deve permettere
di scoprire i difetti del programma prima che venga utilizzato. Il testing si basa principalmente sull'esecuzione
di un programma e il suo problema è che può rivelare la presenza di errori e non la loro assenza. Come primo
passo, i test dovrebbero controllare il normale funzionamento di un programma e dimostrare che il sistema
funziona come previsto. Il secondo passo, i test dovrebbe basarsi sull'esperienza di test su dove sorgono
problemi comuni e utilizzare input anomali per verificare che questi siano elaborati correttamente e non
blocchino il componente.
Inoltre, per scoprire quando il comportamento del software è errato, indesiderato o non conforme alle sue
specifiche, si dovrebbe: fare almeno un test per ogni requisito nel documento dei requisiti, effettuare test
per tutte le funzionalità del sistema, oltre alle combinazioni di queste funzionalità. Per incrementare le
probabilità di realizzare sistemi privi di errori e difetti, insieme al testing si utilizzano anche tecniche di
validazione statica.
Verifica, validazione, convalida e test degli errori
Le attività di validazione hanno, come primo obiettivo, il compito di controllare che il sistema funzioni
correttamente utilizzando un determinato insieme di test che riflettono l'utilizzo previsto del sistema. Il
secondo obiettivo porta alla definizione e esecuzione di test che sono progettati per individuare i difetti. In
questo tipo di operazioni, i test dei difetti possono essere deliberatamente oscuri e non hanno come
obiettivo principale l'individuazione di errori rispetto al modo in cui il sistema viene normalmente utilizzato
e dovrebbero scoprire i difetti nel software quanto il suo comportamento non è corretto o non è conforme
alle sue specifiche.
Pe quanto riguarda la verifica e la convalida, entrambe anno l'obiettivo di poter dichiarare che si sta
costruendo il prodotto giusto. In particolare, la verifica dovrebbe controllare se il software è conforme alle
sue specifiche, e la convalida dovrebbe controllare se il software fa ciò che l'utente realmente richiede.
Quindi, lo scopo della verifica e della validazione è stabilire la certezza che il sistema sia "adatto allo scopo".
Livello di Fiducia sul Software
La fiducia di un sistema dipende dallo scopo del sistema stesso e dalle aspettative degli stakeholder che ha
voluto lo sviluppo di questo sistema. Il livello di fiducia nel sistema dipende da quanto sia critico il sistema
per gli stakeholder. Infatti, più il sistema è critico, più è importante che sia affidabile. Tuttavia, in certe
situazioni la qualità del sistema non è la principale priorità. Ad esempio, per gli stakeholder può essere più
importante lanciare tempestivamente un prodotto sul mercato piuttosto che individuare difetti del sistema.
Inoltre, si è visto che il peso delle aspettative cambia dal momento in cui è stato istallato al momento in cui
il sistema è in piena attività. Infatti, quando viene installato un nuovo sistemali utenti a volte hanno basse
aspettative sulla qualità del sistema e quindi possono tollerare i guasti perché i vantaggi derivanti dall'utilizzo
superano i costi del ripristino dei guasti. Tuttavia, man mano che il tempo di servizio del sistema si allunga,
gli utenti si aspettano che diventi più affidabile.
Ispezioni e Test
Le ispezioni riguardano l'analisi della rappresentazione statica del sistema per scoprire errori e problemi che
potrebbe avere il sistema, e possono essere integrate dall'analisi di documenti e del codice e può essere
basato sull'uso di strumenti specifici.

Come già accennato precedentemente, i test del sistema riguarda la verifica dinamica, cioè l'esercizio e
l'osservazione del comportamento del sistema. In particolare il sistema viene eseguito con dati di test e viene
osservato il suo comportamento operativo.
Le ispezioni e i test sono tecniche di verifica complementari e ambedue dovrebbero essere utilizzate durante
il processo di verifica e convalida. Le ispezioni possono verificare la conformità ad una specifica, ma non la
conformità ai reali requisiti del cliente. Invece i test possono riuscire a verificare la conformità ai reali requisiti
del cliente.
Le ispezioni hanno dimostrato di essere una tecnica efficace per scoprire errori di programma. sono
effettuate da persone che esaminano la documentazione e il codice con l'obiettivo di scoprire anomalie e
difetti e non
richiedono l'esecuzione
ai uni
sistema,
pertanto possono
essere
utilizzate prima
dell'implementazione e quindi le versioni incomplete di un sistema possono essere ispezionate senza costi
aggiuntivi. Oltre alla ricerca dei difetti, un'ispezione può anche prendere in considerazione attributi di qualità
come la conformità agli standard, la portabilità e la manutenibilità, e possono essere applicate a qualsiasi
elemento del sistema (requisiti, progettazione, dati di configurazione, dati di test, ...).
Durante il testing, gli errori possono mascherare (nascondere) altri errori, e se un programma è incompleto,
è necessario sviluppare test specializzati per testare le parti disponibili. Invece, visto che l'ispezione è un
processo statico, non è necessario preoccuparsi delle interazioni tra gli errori.
Le ispezioni non possono verificare caratteristiche non funzionali dinamiche come prestazioni, usabilità, etc.
La figura qui sotto presenta i tipi di elementi che possono essere esaminati per le attività di ispezione e gli
elementi sui cui fare i test.
Inspections
Requirements
specification
Software
architecture
UML design
models
Database
schemas
Program
System
prototype
Testing
Principali fasi di test
L'esecuzione dei test può essere divisa in tre fasi. Nella prima fase vengono fatti i test di sviluppo. In
particolare, il sistema viene testato durante il suo sviluppo per scoprire bug e difetti. Nella seconda fase
vengono fatti i test di rilascio. In particolare, un team di testing testa una versione completa del sistema
prima che venga rilasciata agli utenti. Infine, nell'ultima fase, vengono fatti i test utente. In particolare, gli
utenti o i potenziali utenti di un sistema testano il sistema nel proprio ambiente.
Attività di testing di sviluppo
Andando in più dettaglio, possiamo elencare un certo numero di test che vengono utilizzati per il testing di
un sistema. Questi test sono: unit test, test dei componenti e il test del sistema. L'esecuzione di questi test
inizia con gli unit test che, oltre a testare le singole unità di codice, di classi e di oggetti, si concentrano sul
testing delle funzionalità di oggetti e metodi. Prima di poter eseguire i test dei componenti, in genere, è
necessario integrare questi componenti per creare dei componenti compositi. In questo caso, i test dei

componenti si dovrebbero concentrare sul test delle interfacce dei componenti. Infine, arriviamo ai test del
sistema, in cui alcuni o tutti i componenti di un sistema sono integrati e il sistema viene testato nel suo
insieme e i test si dovrebbero concentrare sulle interazioni tra i componenti.
Test delle classi e degli oggetti
Per poter fornire una copertura completa del test di una classe è necessari fare diverse operazioni. In
particolare, bisogna: testare tutte le operazioni associate a un oggetto, impostare e interrogare tutti gli
attributi dell'oggetto, e esercitare l'oggetto in tutti gli stati possibili.
Alcuni problemi sono dovuti alla presenza di relazioni di ereditarietà tra le classi. Infatti, l'ereditarietà rende
più difficile progettare i test delle classi di oggetti poiché le informazioni da testare non sono localizzate.
Inoltre, i metodi ereditati da una superclasse devono essere testati nuovamente nel contesto delle
sottoclassi. Infine, il test degli elementi nel contesto della superclasse potrebbe non includere tutti i casi che
possono verificarsi nel contesto delle sottoclassi.
Test Automatizzati
Gli unit test dovrebbero essere automatizzati in modo che i test vengano eseguiti e controllati senza
intervento manuale. Per poter automatizzare l'esecuzione dei test si deve avere un framework di
automazione dei test (ad esempio, JUnit). Questi framework forniscono classi di test generici che possono
essere estesi per creare dei test specifici.
L'esecuzione di un test di una sequenza automatizzata è realizzata da alcune fasi: la prima fase è la
configurazione, in cui si inizializza il sistema con il test case, ovvero gli input e gli output attesi. La seconda
fase è la chiamata, in cui viene chiamato l'oggetto o il metodo da testare, la terza fase è asserzione, in cui si
confronta il risultato della chiamata con il risultato previsto. Se l'affermazione risulta vera, il test ha avuto
successo, se falsa, allora ha fallito.
Strategie di Testing
I dati si input e i risultati di output sono due elementi fondamentali, ovviamente se sono di buona qualità.
Con i cosiddetti test di partizione si cerca di identificare dei gruppi di input che devono avere caratteristiche
comuni e essere elaborati allo stesso modo. Individuati e definiti i diversi gruppi, si dovrebbe scegliere i test
all'interno di ciascuno di questi gruppi. I dati di input e i risultati di output spesso rientrano in gruppi diversi
in cui tutti i membri di una classe sono correlati, ciascuno di questi gruppi è una partizione in cui il programma
si comporta in modo equivalente per ciascun membro del gruppo e i test dovrebbero essere scelti da ciascuna
partizione e i test case dovrebbero essere eseguiti con input sia validi che non validi. Infine, per scegliere e
definire i test, spesso si seguono delle linee guida che cercano di far evitare gli errori che spesso i
programmatori commettono durante lo sviluppo del sistema.
9999
10000
50000
100000
99999
Less than 10000
Wrong inputs
Between 10000 and 99999
Correct inputs
More than 99999
Wrong inputs

La figura qui sopra indica la presenza di tre gruppi di dati numerici. Il gruppo centrale contiene dati con u
input corretto e i restanti due contengono dati errati.
Linee Guida sulle Sequenze di Test
Per effettuare del buon testing sono state proposte delle linee guida che indicano delle sequenze di
esecuzione dei test che possono portare a dei buoni risultati. Una delle più conosciute sequenze di esecuzione
dei test indica la seguente sequenza di testing: Si inizia testando il software con sequenze che hanno un solo
valore si continua con sequenze di dimensioni diverse in test diversi, scegliere ed eseguire test su input che
costringano il sistema a generare tutti i messaggi di errore, eseguire test su input che causano l'overflow dei
buffer di input, ripetere più volte test con lo stesso input o con una serie di input, eseguire test che forzano
la generazione di output non validi e test che utilizzano valori troppo grandi o troppo piccoli.
Testing dei Componenti
I componenti software sono spesso componenti compositi costituiti da diversi oggetti interagenti che
permettono di accedere alla funzionalità di questi oggetti tramite l'interfaccia del componente con cui si
vuole interagire. I test dei componenti compositi dovrebbero concentrarsi sulla dimostrazione che
l'interfaccia del componente si comporta secondo le sue specifiche.
Tipi di Interfacce
Esistono tre tipi principali di interfacce: interfacce con parametri, interfacce di memoria condivisa, interfacce
procedurali e interfacce per lo scambio di messaggi
Le interfacce con parametri passano dati o talvolta riferimenti a funzioni da un componente all'altro e
vengono utilizzato da metodi e oggetti.
Le interfacce di memoria condivisa utilizzano un blocco di memoria condiviso tra i componenti.
Le interfacce procedurali vengono implementate da un componente che fornisce un insieme di procedure
che possono essere chiamate da altri componenti e vengono utilizzate da oggetti e componenti riutilizzabili.
Le interfacce per lo scambio di messaggi richiedono un servizio a un altro componente tramite un messaggio
e ricevono un messaggio di ritorno include i risultati dell'esecuzione del servizio. Questo tipo di interfaccia è
utilizzato dai sistemi client-server.
Linee Guida del Testing delle Interfacce
Per effettuare il testing delle interfacce sono state proposte delle linee guida che consigliano di: progettare i
test in modo che i parametri di una procedura chiamata si trovino agli estremi dei relativi intervalli, testare
sempre i parametri usando almeno un valore null, progettare dei test che causano il guasto di un
componente, utilizzare lo stress test nei sistemi di scambio di messaggi e variare l'ordine in cui i componenti
vengono attivati nei sistemi a memoria condivisa.
Errori delle Interfacce
Gli errori più frequenti nell'uso delle interfacce sono: l'uso improprio dell'interfaccia, Incomprensione
dell'interfaccia e gli errori di tempistica.
Uso improprio dell'interfaccia: un componente chiama un altro componente e commette un errore nell'uso
della sua interfaccia, ad esempio, i parametri sono nell'ordine sbagliato.
Incomprensione dell'interfaccia: un componente chiamante incorpora presupposti errati sul comportamento
del componente chiamato.

Errori di tempistica: il componente chiamato e quello chiamante operano a velocità diverse e quindi accede
a informazioni non aggiornate.
Stub, driver e test double
Stub e driver sono due tipi di test, ovvero una raccolta di software e test configurati insieme per testare
un'unità di un programma stimolando una varietà di condizioni e monitorando costantemente i suoi output
e il suo comportamento. Stub e driver vengono utilizzati rispettivamente nei test di integrazione top-down e
bottom-up e vengono creati principalmente a scopo di test.
Generalmente, gli stub vengono creati dagli sviluppatori di software per utilizzarli al posto dei moduli se i
moduli particolari mancano o non sono ancora stati sviluppati. Utilizzando questi test stub, gli ingegneri di
test possono simulare le prestazioni dei moduli di livello inferiore, che non sono ancora integrati nel software.
I driver sono sviluppati principalmente nell'approccio bottom-up dei test di integrazione incrementale. In
particolare, i driver sono un po' complessi rispetto agli stub e sono utilizzati per testare i livelli inferiori del
codice quando i moduli o i codici di livello superiore non sono sviluppati o mancano.
I test double utilizzano un oggetto o componente al posto del componente reale per eseguire il test. Questo
oggetto o componente non deve comportarsi esattamente come il componente reale, ma deve
semplicemente fornire la stessa API di quella reale in modo che il sistema pensi che sia quella reale. In
particolare, esistono quattro tipi di test double: dummy object, test stub, mock object e fake object. Qui sotto
sono presentati gli esempi di codice dei diversi test double.
publie class WarehouseDuty implemente warshouse
@Override
public int getinventory (final String product)
return e;
•Override
public boolean hasinventory(final String product)
{
return false;
@Override
public void add(final String product, final int i)
public interface Warehouse
int getEnventory(String product);
boolean hasInventory(String product);
void add(String product, int 1);
void renove(String product, int s):
dOverride
public void remove(final String product, final int i)
Un dummy object è una classe crea oggetti "segnaposti" che
vengono passati al codice come parametri, ma non sono mai utilizzati

public class NarehouseStub Implements karehouse
@Override
publte int getinventory (final String product)
if (product.equals("product1"))
return 5;
return e;
public boolean hasInventory (final String product)
* (product, equals (products'")
, return true;
return false;
@Override
public void add(final String product, final int 1)|
Un test stub un oggetto utilizzato per sostituire un componente reale
per forzare il sistema lungo il percorso che vogliamo per il test
#Override
public void renove(final String product, final int 1)
pubite class Harehousewock Impienents Marahoule
nivate int InventoryResult
eivate boolean hasinventoryResult
Override
public int getinventory(final String product)
return this.inventoryResult;
public void setoe inventory resuittinal ant resuat)
this. inventoryResult • result;
Un mock object è un oggetto che
viene utilizzato per sostituire un
componente reale e che restituisce
valori codificati o precaricati
public boolean hasinventory(final String product)
return this.hasInventoryResult;
public void sethesinventorykesult(final boolean value)
this.hasInventoryResult • value;
publie void add(final String product, final int 1)
public void renove(final String product, final int 1)|

public class Narehouzefate Impleserts Marehouse
private Nap<String,
Integer> inventory • new Mashhap<>
tap.of("prodl", 3, "prodz", 5, "prod3", 11, "prod4", 2)):
public int getinventory (fanal String product)
return current (product);
publie boolean hasinventory(final String product)
return (current(product) › ®):|
ereidel
publie void add(final String product, final int S)
inventory.put (product, current(product) • 1):
public void renove(final String product, final int 1)
inventory-put (product, current(product) • 1):
private int current(String product)
"(nventory-@et(product) la null
return inventory-get(product);
Un fake object è un oggetto che sostituisce la funzionalità
dell'oggetto reale con un'implementazione alternativa
Testing del Sistema e dei Componenti
Il test del sistema durante lo sviluppo prevede l'integrazione di componenti per creare una versione del
sistema e quindi testare il sistema integrato. L'obiettivo nel test del sistema è testare le interazioni tra i
componenti e verificare il comportamento del sistema. In particolare, i test di sistema verificano che i
componenti siano compatibili, interagiscano correttamente e trasferiscano i dati giusti al momento giusto
attraverso le loro interfacce.
Durante i test del sistema, i componenti riutilizzabili che sono stati sviluppati separatamente e i sistemi |
standard possono essere integrati con componenti di nuova concezione; inoltre, possono essere integrati
componenti sviluppati da diversi membri del team. Il test del sistema è un processo collettivo piuttosto che
individuale. In alcune aziende, il test del sistema può coinvolgere un team di test separato senza alcun
coinvolgimento di progettisti e programmatori del sistema.
Testing dei Casi di Uso
I casi di uso sono sviluppati per identificare le interazioni del sistema e possono essere utilizzati come base
per il test del sistema. Ogni caso di uso solitamente coinvolge diversi componenti del sistema, quindi testare
un caso di uso forza l'esecuzione di queste interazioni. I diagrammi di sequenza associati ai documenti dei
casi di uso identificano i componenti e le interazioni che vengono testate.

Test sugli Stati di una Stazioni Meteorologica
g- Testing- Transmitting -> Running
Il testing di un sistema, in cui il suo funzionamento comporti il passaggio da uno stato ad un altro, deve
provare che questi passaggi di stato non creino problemi al funzionamento del sistema. Il particolare, si
consiglia di eseguire sequenze in cui: vengono eseguiti dei passaggi di stato che devoto coinvolgere tutti gli
stati, vengono eseguiti test con sequenza che, via via, aumentano il numero di passaggi di stato e, infine, che
eseguono le sequenze con un diverso ordinamento dei passaggi di stato.
Test dei casi di uso con interazione manuale
Quando un sistema software è stato completato, altre a verificare che tutti i test software sono stati eseguiti
con successo, si possono fare degli ulteriori test in cui gli utenti vanno ad eseguire le sequenze di operazioni
che gli utenti dovranno eseguire quando in sistema andrà in produzione. In genere, per eseguire questi test,
usano i casi di uso che sono stati definiti durante lo sviluppo del sistema e che, ovviamente, dovrebbero
essere stati sviluppati proprio in base alle informazioni fornite dai casi di uso. Qui sotto è presentato un
esempio di caso di uso che fornisce le informazioni per permettere a un utente di controllare la sue
correttezza.
Use case Name: Show Student Marks
Actors: Students, Teachers, Parents
1) The system must be connected to the setwerk
2) Actors must have a "Student 10.
Main Scenario
A ACCor
Steps
System Validates Student Name
Enter Student 10
System Validates Student ID
System shows Student Marks
S: Shows an error message
10

Steps
Enter Student Name
System Validates Student Name
Enter Student ID
System Validates Student I0
System shows Student Marks
Expected Result
Enter atudent han
Enter Student ID
Click en View Mark |
View Student Mark List 2-Invalia ID
Repeat steps 1 and 2 of View Student Mark List 1 |
2 Enter Student 1D
User can enter Student name
User can enter Student ID
System displays Student Marke
S: Shows an error message
Test di Regressione
Si testa il sistema per verificare che le modifiche non abbiano "corrotto" il codice precedentemente
funzionante. In un processo di test manuale, il test di regressione è costoso ma, con il test automatizzato, è
semplice e diretto. Tutti i test vengono eseguiti nuovamente ogni volta che viene apportata una modifica al
programma. I test devono essere eseguiti "con successo" prima che la modifica venga confermata.
Test di Rilascio
È il processo di test di una particolare versione di un sistema destinata all'uso al di fuori del team di sviluppo.
L'obiettivo principale del processo di test di rilascio è convincere il fornitore del sistema che è
sufficientemente buono per l'uso. I test di rilascio, quindi, devono dimostrare che il sistema offre funzionalità,
prestazioni e affidabilità specificate e che non fallisce durante il normale utilizzo. Il test di rilascio è
solitamente un processo di test black-box in cui i test derivano solo dalle specifiche del sistema il test di
rilascio è una forma di test del sistema. Un team separato, non coinvolto nello sviluppo del sistema, dovrebbe
essere responsabile dei test di rilascio. Il test del sistema da parte del team di sviluppo dovrebbe concentrarsi
sulla scoperta dei bug nel sistema (test dei difetti). L'obiettivo del test di rilascio è verificare che il sistema
soddisfi i suoi requisiti e sia sufficientemente buono per un uso esterno (test di validazione).
Test delle Prestazioni
Parte del test di rilascio può comportare il test delle proprietà emergenti di un sistema, come prestazioni e
affidabilità. I test dovrebbero riflettere il profilo di utilizzo del sistema. I test delle prestazioni di solito
comportano la pianificazione di una serie di test in cui il carico viene costantemente aumentato fino a quando
le prestazioni del sistema diventano inaccettabili. Lo stress test è una forma di test delle prestazioni in cui il
sistema viene deliberatamente sovraccaricato per testare il suo comportamento in caso di guasto.
Test dell'Utente
È una fase del processo di test in cui gli utenti/clienti forniscono input e consigli sul test del sistema. È
essenziale, anche quando sono stati effettuati test completi del sistema e del rilascio. L'influenza
dell'ambiente di lavoro dell'utente hanno un effetto importante sull'affidabilità, le prestazioni, l'usabilità e
la robustezza di un sistema. Questi non possono essere replicati in un ambiente di test.

In particolare, gli utenti sono spesso coinvolti nelle attività dei test di accettazione che devono decidere se il
sistema sviluppato è accettabile dal cliente. Le attività di accettazione sono di tre tipi: alfa test, beta test e
test di accettazione.
Durante l'alfa test, gli utenti del software collaborano con il team di sviluppo per testare il software presso il
sito degli sviluppatori.
Durante il beta test viene messa a disposizione degli utenti una versione del software per consentire loro di
individuare i problemi del sistema.
Durante il test di accettazione i clienti testano nel loro ambiente il sistema per decidere se è pronto o meno
per essere accettato.
Il diagramma qui sotto descrive le azioni e gli elementi coinvolti nel test di accettazione.
Test
criteria
Metodi agili e test di accettazione
Nei metodi agili l'utente/cliente fa parte del team di sviluppo ed è responsabile di prendere decisioni
sull'accettabilità del sistema. I test sono definiti dall'utente/cliente e sono integrati con altri test in quanto
vengono eseguiti automaticamente quando vengono apportate modifiche. Non esiste un processo di test di
accettazione separato. Il problema principale qui è se l'utente/cliente sia o meno in grado di rappresentare
gli interessi di tutte le parti interessate al sistema.
12

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L12-Pattern software (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Problemi e pattern software
I problemi software hanno spesso cause e soluzioni comuni. In particolare, le soluzioni possono essere
astratte e riutilizzate in contesti diversi. I pattern software (detti anche pattern di progettazione) sono un
modo per catturare e comunicare queste soluzioni in modo sistematico e coerente. In particolare, i sistemi
orientati agli oggetti di buona qualità mostrano strutture ricorrenti che promuovono: astrazione, flessibilità,
modularità e eleganza. Tali strutture rappresentano una preziosa conoscenza progettuale per lo sviluppo di
qualsiasi tipo di sistema. Il problema è trovare i mezzi giusti per catturare, comunicare e applicare questa
conoscenza.
L'idea del pattern viene da Christopher Alexander, un architetto che utilizza tale idea per affrontare problemi |
architettonici, di progettazione urbana e di vivibilità della comunità. Partendo dall'idea di Christopher
Alexander, quattro ricercatori Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, hanno definito
i pattern software. Questi ricercatori sono conosciuti come la Gang of For (GoF)
Hanno scritto il primo libro sui pattern software, il duo titolo è "Design Patterns"
Partendo da questa idea, quattro ricercatori: Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides,
conosciuti come la Gang of Four (GoF), hanno fornito una prima definizione dei pattern software e Sono gli
autori del primo libro sui pattern software: "Design Patterns".
Pattern software
Un pattern software è indipendente dal linguaggio e dall'implementazione e offre una soluzione ricorrente a
un problema standard in un contesto specifico. In genere, descrive un problema che si verifica ripetutamente
e fornisce una soluzione a quel problema in un modo che consenta di utilizzare quella soluzione un milione
di volte, senza mai farlo due volte allo stesso modo. In particolare, in particolare, un pattern software è una
descrizione del problema e l'essenza della sua soluzione che permette di riutilizzare la conoscenza astratta di
un problema e della sua soluzione. Inoltre, si dice che un pattern software dovrebbe essere sufficientemente
astratto da poter essere riutilizzato in contesti diversi, e che le descrizioni dei pattern software ,di solito,
fanno uso di caratteristiche orientate agli oggetti come ereditarietà e polimorfismo. Ovviamente, l'obiettivo
dei pattern software è fornire degli strumenti utili a realizzare del buon software e facilmente comprensibile
anche da persone non esperte. In particolare, si dice che bisogna: realizzare della buona progettazione,
catturare e preservare le informazioni di progettazione, articolare le decisioni di progettazione in modo
conciso, assegnare nomi espliciti alle strutture di progettazione, facilitare la ristrutturazione e il refactoring,
aggiungere flessibilità, migliorare la documentazione, individuare le correlazioni con altri pattern, distillare e
diffondere l'esperienza sui pattern software e, infine, aiutare sia ai principianti che agli esperti.
Descrizione di base dei pattern software
Una usuale descrizione di un pattern software compre i seguenti attributi:
Nome - che deve essere un chiaro identificatore del suo significativo
Descrizione del problema - che spiega il problema e il suo contesto
Descrizione della soluzione - che è una soluzione progettuale astratta che può essere istanziata in diversi
modi
Conseguenze - che introducono i risultati e i compromessi dell'applicazione del pattern
Nella figura qui sotto sono introdotti gli elementi

Dare un nome ai pattern consente al design di lavorare a
un livello di astrazione più elevato, utilizzando un
Nome e
vocabolario di pattern
classificazione
Gamma affermava che trovare un buon nome è uno dei
problemi più difficili nello sviluppo di un catalogo di
pattern
Intento
Una risposta a domande come: cosa fa il pattern? Quale
problema affronta?
Anche
ConosCuro
come
Motivazioni
Altri nomi per il pattern
Applicabilità
Struttura
Partecipanti
Collaborazioni
Conseguenze
Implementazioni
Esempi di
codice
Usi conosciuti
Uno scenario concreto che illustra un problema di
progettazione e il modo in cui il pattern risolve il problema
Istruzioni su come riconoscere le situazioni in cui i pattern
sono applicabili
Una rappresentazione grafica delle classi del pattern
Le responsabilità delle classi e degli oggetti che
partecipano al pattern
Come i partecipanti collaborano per adempiere alle
proprie responsabilità
I risultati, gli effetti collaterali e i compromessi del
suo utilizzo
Guida all'implementazione del pattern
Frammenti di codice che illustrano
l'implementazione del pattern
Dove trovare esempi reali del pattern
Pattern correlati | Sinergie, differenze e altre relazioni dei pattern
Classificazione dei pattern di progettazione
Pattern creazionali - creano oggetti della classe giusta per un problema e sono utili quando è necessario
scegliere tra diverse classi in fase di esecuzione anziché in fase di compilazione.
Pattern strutturali - formano strutture più grandi da singole parti e variano a seconda del tipo di struttura e
scopo.
Pattern comportamentali (runtime) - supportano le interazioni degli oggetti e la selezione dell'algoritmo che
una classe utilizza in fase di runtime.
Pattern di oggetti - (runtime) - consentono l'utilizzo delle istanze di classi diverse nella stessa posizione in un
pattern, evitano di correggere la classe che esegue una determinata attività in fase di compilazione e
utilizzano principalmente la composizione di oggetti per stabilire relazioni tra oggetti.
Pattern di classe (compile-time) - tendono a utilizzare l'ereditarietà per stabilire relazioni, generalmente
fissano le relazioni in fase di compilazione e sono meno flessibile e dinamico e meno adatto ad approcci
polimorfici.
4

Principali Pattern dei GoF
Pattern creazionali: Abstract Factory, Factory Method, Builder, Prototype, Singleton.
Pattern strutturali: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.
Pattern comportamentali: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento,
Observer, State, Strategy, Template, Visitor.
Creazione flessibile
Spesso è necessario nascondere come vengono creati gli oggetti per rendere un sistema indipendente da
come i suoi oggetti vengono creati e composti. Ad esempio, un sistema può essere configurato con una delle
molteplici famiglie di prodotti. La famiglia e quindi le classi da istanziare possono essere conosciute solo in
fase di runtime.
Scopo e applicabilità del pattern del metodo factory
Intento - Definire un'interfaccia per la creazione di un oggetto e rimandare l'istanziazione alle sottoclassi.
Applicabilità - Una classe non può anticipare la classe di oggetti che deve creare e delega la responsabilità a
una delle numerose sottoclassi.
Applicazione del pattern factory
Retrobut(string », Mont ») 4
-price: float
-Mitkiprice: float)
Coetaneo eal
Intento e applicabilità del pattern builder
Intento - separare la costruzione di un oggetto complesso dalla sua rappresentazione in modo che lo stesso
processo di costruzione possa creare rappresentazioni diverse.
Applicabilità - quando l'algoritmo per creare un oggetto complesso dovrebbe essere indipendente dalle
parti che compongono l'oggetto e da come sono assemblate e quando il processo di costruzione deve
consentire diverse rappresentazioni dell'oggetto costruito.

Struttura del pattern builder
Applicazione del pattern builder
LUNA Debe Centent Paralert
Codice Java del pattern builder
48000 Flees
Perate here posse
Class HawallanPlazabuilder extends Pizzabuilder I
publie void buflaDough)
public vold bulldSauced)
( pizza.setDough("cross"): )
( plaza.setsauce(*esle"): )
publie void buildtopping() ( pizza,settoppine("hanspinesele"): ›
polle vold bulldbough)
( plaza.setDough (*pan baked"): )
public void buildtopping() ( pizza.settopping("pepperondesalans*): )

Intento e applicabilità del pattern singleton
Intento - assicurarsi che una classe abbia solo un'istanza e fornire un punto di accesso globale ad essa.
Applicabilità - quando è consentita solo un'istanza (o un numero specifico di istanze) di una classe e quando
deve essere accessibile ai client da un punto di accesso globale.
Struttura del pattern singleton
Singleton
-uniquenstance : Singleton
- singletonData
*instanca()- - - -- -1
*singletonOperation()
*getSingletonData()
(return un/queinstance; )|
Applicazione del pattern singleton
Codice Java del pattern singleton
publie class DoubleChechedteckingsingleton
private static DoubleCheckedLockingSingleton singieton;
public static DoubleCheckedLockingsingleton getiesterce)
(* (aingleten e mall)
pynchronited (DeubleCheciefLock/ngSingleton.clm)
singleton e new DoubleCheckedlockingSingleton():
public class SynchronizedSingleton
private static SynchronizedSingleton singleton;
private SynchronizedSingleton()
Il attributes and ne
public static synchreetted SyechroniteSirgieton getienti
1f (singleton un null)
singleton e new Synchronizessingleton():
return singleton;
Il attributes and nethods ....
palle dens tegesingieten
private static tegersingieten aingieton • new tagersingieton():|
pelte tegertingieteD
polle statie tagersingieten getistanced
reture singleten;
wbile clan tesidingieten
pelvate statie tassesingleton singieton;
hote antesigite)
polte static Besicsingieton getzestance)
(* (alogietes ne nell)
singleton e neu fasicsingleton():
, return singleton;
11 attributes and nethods ...
public enun Enasingieton
SINGLETON;
, " attributes and nethots

Riuso del software
Current Code
Xpay API
Current Code
Ipay API
Scopo e applicabilità del pattern adapter
intento - convertre iv erteria di una classe in un'altra interfacci attesa dai client e avolgere una classe
Applicabilità - quando una classe già esistente fornisce alcuni o tutti i servizi necessari, ma non implementa
l'interfaccia richiesta.
Caratteristiche principali del pattern adapter.
Il pattern utilizza ereditarietà e delega. L'ereditarietà viene utilizzata per specificare l'interfaccia della classe
adapter. La delega viene utilizzata per vincolare l'adattatore e l'affidato
Struttura del pattern
class adeoter
Struttura del pattern
coleo-ot
Fatte volt gentevoito
walte volt getizvelt() 1
«tura convertvelt(e, 19)1
malle volt gesavito) !
sta contrvello, e)
etere Convertone
retare neu Volt(v-getelts) / 1):

Scopo e applicabilità del pattern composite
Intento - trattare in modo uniforme oggetti singoli e multipli composti ricorsivamente.
Applicabilità - gli oggetti devono essere composti in modo ricorsivo e non c'è nessuna distinzione tra
elementi singoli e composti.
Struttura del pattern composite
Codice Java del pattern composite
public abstract class utaltag (
public abstract String pettagtane():
public abstract vold setstarttas(string st);
public abstract vold setindtag(String et):
public abstract void settagiody(String tb):
publie class HtmlContainerElement extends Htmltag (
peivate String startTag:
peivate String endtag;
private String tagBody:
peivate List@italTag childrentag;
public class Htmlklement extends Mtaltag (
private String taglane;
peivate String endtae:
peivate String tagBody;
Intento e applicabilità del pattern decorator
Intento - assegnare nuove responsabilità a un oggetto fornendo dinamicamente un'alternativa flessibile
all'uso di sottoclassi per estendere le funzionalità.
Applicabilità - aggiungere e rimuovere responsabilità ai singoli oggetti in modo dinamico e trasparente,
ovvero senza influenzare altri oggetti. Si utilizza quando l'estensione tramite sottoclassi non è praticabile.
Infatti, un gran numero di estensioni indipendenti potrebbe causare un'esplosione di sottoclassi per
supportare tutte le combinazioni.

Struttura del pattern decorator
imponent.-Operation
Esempio di decorator di automobili
Codice Java del decorator di Automobili
protected Car car;
pubite Cardecorator (final Car e)
this.car . c;
@Override
pubite vold assembled)
thas.cer.assevo-e()
publie class BasicCar implements Car|
Override
publie void assenble()
Systen.out.print("Basic Car."):
public class Sportar extends Cardecorator
fublte Sporter (final Car c)
super (c):
public interface Car
public void assemble():
Override
publie void assenble()
super .assenble();
Systen.out.print(* Adding features of Sports Car.*);|
10

puoise intertace Decoratorvend
public statte vozd main(stringi) arga)
Car sportsCar = new SportCar(new BasicCar()):|
sportsCar.assenble();
Systen.out.println(*\*******):
Car sportaLuxurycar a nenpubité class Linurycar entends Cardecorator
sportstuxury Car.assenbiec
public Lanny Car(tina) Car e)
super (c);
public vola aieroid
super.assenble();
pubite interface DecoratorCens
public static void main(strinat) argo)
Car sportaCar • neu SportCar (new BasicCar ()):
sportsCar.assenble():
Systen.out.peintln(*\д******):
Car sportsluxuryCar e new SportCar (new LuxuryCar(new BasicCar())):|
ing futures if laury ter, Miling festeres of Sports Cor.
Interazione Flessibile
Clienti
Client2
RealSubject3
+operationiO
+operation20
Intento e Applicabilità del Pattern Proxy
Intento - Fornire un surrogato o un segnaposto per un altro oggetto per controllarne l'accesso, utilizzare un
ulteriore livello di riferimento indiretto per supportare l'accesso distribuito, controllato o intelligente e
aggiungere un rapper e delega un oggetto proxy per proteggere il componente reale.
11

Applicabilità - quando è necessario controllare l'accesso a un oggetto e quando è necessario un riferimento
sofisticato a un oggetto.
Struttura del pattern proxy
Applicazione del pattern proxy
Tipi di pattern proxy
Proxy virtuale (oggetti costosi)
Proxy cache (oggetti temporanei)
Proxy remoto (oggetti remoti)
Proxy di protezione (oggetti condivisi)|
Riferimento intelligente (estensione del puntatore)
Codice Java di pattern proxy
public intertace CommandExecutor
public void runComand(String cad) throws Exception;
publie class CommandExecutorimpl Implements CommandExecutor (
POverride
publie void runConnand(String (nd) throws 10Exception (|
I/some heavy Implementation
Runtine.getRuntine().exec(cnd);
Systen.out.println(***+ cad + "' cornand executed.");
12

publie class ComandIxecutorProxy Emplements Comandicecutor (
private boolean isadain:
private ComandExecutor executoril
public ComandExecutorieoky (String user, string pud) (
St ("Pankaj"-equale (unes) 66 "JBurnalDOv"-eguale (pud)) |
ischin ~ true;
executor = new CommandExecutortapll>
doverride
#t (Lasdnin)(
executor. runcomand (and)/
18 (cmd. trimO -atartakith (*m")) (
throw new Exception ("am comand ia not alloved for non-adain usera.") ›
executor. runConnand (ond)
Esecuzione flessibile
A volte è necessario inviare richieste agli oggetti senza sapere nulla dell'operazione richiesta o del
destinatario della richiesta
Una libreria di toolkit/widget dell'interfaccia utente include pulsanti e menu che eseguono una richiesta
corrispondente all'input dell'utente
pureb e sere tato e su quali etentare esplicitamente l'azione, perché solo un'applicazione sa cosa
Intento e Applicabilità del pattern command
Intento - incapsulare la richiesta di un servizio
pola le que de is armonia e etico a uefa are ie, ane si speciane
Struttura del pattern command
Receiver
secever
recelver. actiond
wire santiates
Applicazione del pattern command
13

Application
Menu
950jn m: Mond
ocereand encuted
document pael
Elaborazione eventi senza/con command pattern
public interface Command
public void execute():
public void actionPerformed(ActionEvent e)
Object o = e.getSource():
if (o instanceof fileNewMenultem)|
doFileNewAction():
else if (o instanceof fileOpenMenultem) |
doFileOpenAction():
else if (o instanceof
fileOpenRecentMenultem)
doFileOpenRecentAction():
else if (o instanceof fileSaveMenultem)|
doFileSaveAction():
// and more...
public class FileOpenMenultem
extends jMenultem implements Command
public void executel
Il your business logic goes here
public void actionPerformed(ActionEvent e)
Command command = (Command) e.getSource();
command. execute():
Disaccoppiamento di oggetti di confine e controllo
Il comand pattern può essere utilizzato bene per disaccoppiare gli oggetti "boundary" dagli oggetti di
controllo. Gli oggetti "boundary", come voci di menu e pulsanti, inviano comandi agli oggetti di controllo.
Solo gli oggetti di controllo modificano gli oggetti "entity". Quando viene modificata l'interfaccia utente, è
necessario modificare solo gli oggetti "boundary".
Comportamento Flessibile
Molte classi correlate differiscono solo nel comportamento piuttosto che nell'implementazione di diverse
astrazioni correlate. Per risolvere un problema è possibile utilizzare diverse varianti di un algoritmo. Una
classe definisce molti comportamenti che appaiono come più istruzioni condizionali.
Intento e Applicabilità del Pattern Strategy
Intento - definire una famiglia di algoritmi, incapsularli ciascuno e renderli intercambiabili per consentire ai
client e agli algoritmi di variare in modo indipendente.
14

Applicabilità - quando un oggetto dovrebbe essere configurabile con uno dei tanti algoritmi, quando tutti gli
algoritmi possono essere incapsulati e quando un'interfaccia copre tutti gli incapsulamenti
Struttura del pattern strategy
Context
*executel
-strategy
Strategy
strategy.algorithmo
ConcreteStrategy!
*algorithmi
ConcreteStrategy?
*algorithmO
Applicazione del pattern strategy
Timelsimportant
Spacelsimportant
SelectSort AlgorithenD
Sortinterface
Serto
Bubblesort
Quick Sort
Mergeson
Serto
LocationManager
Application
ed incartaced
Codice Java del pattern strategy
15

public interface Strategy {
public int doperation(int numi, int nun2);
public class OperationAdd implements Strategy(
goverride
public int doOperation(int numl, int nun2) ‹|
return nuni + nun2;
public class OperationSubstract implements Strategy(
public int
dooperation(int nuni, int nun2).
public class OperationBasicMultiply implements Strategy {
soverrioel
public int dooperation (int
numl, int num2) (
public class Context (
private Strategy strategy;
public Context(Strategy strategy
this strategy • strategys
public int executestrategy(int n
return strategy.dooperation(n
public class OperationRecursiveMultiply implements Strategy (
@Override
public int doOperation(int nuni, int nun2) (
if (nun2 == 1) (|
else (
return numi • doOperation(nuni, •-nun2);
Intento e applicabilità del visitor pattern
Intento - rappresentare un'operazione da eseguire sugli elementi di una struttura di oggetti e definire una
nuova operazione senza modificare le classi degli elementi di una struttura di oggetti.
Applicabilità - Operazioni simili devono essere eseguite su oggetti di diverso tipo raggruppati in una struttura,
ci sono molte operazioni distinte e non correlate da eseguire. È improbabile che la struttura dell'oggetto
venga modificata, ma è molto probabile che siano presenti nuove operazioni da aggiungere.
Struttura del Visitor Pattern
Visitor
Concrete Visitor1
ConcreteVisitor2
Object structure
Element
accepiviste : Vskor): vell
ConcreteElementA
accopa(vistor : Vakor): veid
ConcreteElements
ассер(увки : Vhw): vol
16

Applicazione del Visitor Pattern
sublic interface Visitor 1
/oid doForCity(City c):
void doFor Industry(Industry i);
void doForSightSeeing(Sightseeing s);
public class VisitorBadDeno (|
ublic static void main(Stringl) args)
ist<node › nodes • new ArrayList‹>():
// Sets the nodes.
visitor v = new Concretevisitor();
// Creates instance of concrete class.
for (Node n : nodes) (
if (n instanceof City)
v.doforcity((City) n);|
1f (n instanceof Industry)
v.doFor Industry((Industry) n);
if (n instanceof SightSeeing)
v.doforsightSeeing ((SightSeeing) n):|
public class VisitorGoodDeno (
public static void main(String[] args) 1
List‹Node › nodes • new ArrayList>():
// Sets the nodes.
Visitor v = new Concretevisitor();
// Creates instance of concrete class.
Ir (Node n : nodes)
.accept (v)
public class City implements Node (
Override
public void accept(visitor v) (
v.doforCity(this);
17

UNIVERSITÀ DEGLI STUDI DI PARMA
Dispense di Ingegneria del Software
L13 - Evoluzione del software (dispensa)
Prof. Agostino Poggi
A.A. 2024/2025
1

Cambiamento del software
In genere un software che è molto utilizzato ha sempre bisogno di evolvere. Infatti, quando si utilizza un
sistema software emergono nuove esigenze per vari motivi: l'ambiente imprenditoriale cambia, sono
identificati degli errori da riparare, dei nuovi computer e altri tipi di dispositivi sono aggiunti al sistema e
infine, può essere necessario cercare di migliorare le prestazioni e/o l'affidabilità del sistema.
Le aziende fanno enormi investimenti nei loro sistemi software, visto che sono risorse aziendali fondamentali.
La maggior parte del budget software nelle grandi aziende è destinato al cambiamento e all'evoluzione del
software esistente, ma lo sviluppo di nuovo software è alquanto limitato. Per mantenere il valore delle risorse
dell'azienda, è necessario modificarle e aggiornarle. Un problema chiave per l'azienda è inizialmente
l'implementazione del sistema software e in seguito la gestione delle modifiche al sistema.
Evoluzione, manutenzione e eliminazione graduale
L'evoluzione è una fase del ciclo di vita di un sistema in cui il sistema evolve, man mano, che nuovi requisiti
vengono proposti e implementati. La manutenzione è una fase in cui il software rimane utile, non vengono
aggiunte nuove funzionalità, e le nuove modifiche sono dovute alle correzioni di bug e alle eventuali
modifiche necessarie per gestire i cambiamenti. Infine, l'eliminazione graduale è una fase in cui il software
può ancora essere utilizzato ma non vengono apportate ulteriori modifiche. La figura qui sotto indica il ciclo
di vita di un sistema che parte dallo sviluppo del sistema software e termina con l'eliminazione del sistema.
development
Software
Software
servicing
Software
retirement
Processi di evoluzione
I processi di evoluzione del software dipendono da molti elementi: il tipo di software da mantenere, i processi
di sviluppo utilizzati nell'azienda, le competenze e l'esperienza delle persone coinvolte nell'attività di
evoluzione del sistema. In particolare, l'evoluzione del sistema è in gran parte guidata dalle proposte di
modifiche degli stakeholder. Ovviamente, l'applicazione di modifiche deve essere valutata in base alla stima
del costo e dell'impatto della modifica. Inoltre, finché un sistema è produttivo, l'identificazione e
l'applicazione di modifiche continua per tutta la vita del sistema.
L'evoluzione del software è necessaria anche per i sistemi sviluppati con metodi agili. Come sappiamo,
questo approccio si basa sullo sviluppo incrementale e quindi la transizione dallo sviluppo all'evoluzione
avviene senza soluzione di continuità. Quindi l'evoluzione è semplicemente una continuazione del processo
di sviluppo basato su frequenti rilasci di versioni del sistema. Le modifiche possono essere espresse come
storie utente aggiuntive e il test di regressione automatizzato è particolarmente utile quando vengono
apportate modifiche a un sistema.
In gran parte dei casi, gli sviluppatori del sistema originale non sono responsabili dell'implementazione del
cambiamento. La prima fase di implementazione del cambiamento può comportare la comprensione del
programma. Durante la fase di comprensione del programma, i nuovi sviluppatori devono capire come è
strutturato il programma, come realizza le funzionalità e in che modo le modifiche proposte potrebbero
influenzare il programma. La figura qui sotto indica la sequenza di fasi per eseguire le modifiche richieste. La
sequenza di fasi parte dallo richiesta di cambiamenti e termina con il rilascio del sistema software modificato.
Change
requests
Analyze
source code
Modify
source code
Deliver modified
system

Richiesta di modifiche urgente
Spesso un sistema può richiedere modifiche urgenti. Situazioni del genere possono crearsi, ad esempio, se è
necessario riparare un guasto grave del sistema per consentire il proseguimento del normale funzionamento,
se un aggiornamento del sistema ha avuto degli effetti imprevisti e se alcuni cambiamenti aziendali
richiedono una risposta molto rapida (e.g., anticipare il rilascio di un prodotto concorrente).
Sistemi legacy
Sono sistemi di vecchia realizzazione che si basano su linguaggi e tecnologie che non vengono più utilizzate
per lo sviluppo di nuovi sistemi, visto che possono dipendere da hardware meno recente, come i computer
mainframe e possono avere processi e procedure legacy associate. Questi sistemi, non sono solo sistemi
software ma sono sistemi socio-tecnici più ampi che includono la partecipazione di utenti, hardware,
software, librerie e altri software di supporto e processi aziendali. La figura qui sotto identifica gli elementi
di un sistema tipico e le relazioni tra i diversi elementi.
Embeds
knowledge of
Support
software
Runs-on
Uses
Runs-on
Application
software
Uses
Business policies
and rules
Uses
Constrains
System
hardware
Application
data
Business
processes
In particolare, gli elementi del sistema presenti qui sopra sono: hardware di sistema, che potrebbe essere
stato sviluppato con un hardware che non è più disponibile; software di supporto, che potrebbe fare
affidamento su una serie di software di supporto, che possono essere obsoleti o non supportati; software
applicativo, che potrebbe fornire i servizi aziendali; dati dell'applicazione, che potrebbero essere elaborati
dal sistema legacy, che potrebbero generare dati incoerenti e duplicati e che potrebbero essere conservati
in database diversi.
I processi aziendali sono processi utilizzati per raggiungere determinati obiettivi. In particolare, possono
essere progettati attorno a un sistema legacy e vincolati dalle funzionalità che il sistema fornisce. Inoltre, le
politiche e regole aziendali indicano come deve essere svolta l'attività del sistema e quali sono i vincoli
sull'attività. L'uso di un sistema applicativo legacy può essere incorporato in queste politiche e regole.
Sostituzione dei sistemi legacy
La sostituzione di un sistema legacy è rischiosa e costosa per una serie di motivi. Spesso mancano le specifiche
complete del sistema, le regole aziendali non sono documentate e integrate nel sistema, il sistema può essere
stato implementato con linguaggi di programmazione obsoleti, e quindi, potrebbe essere difficile trovare
delle persone disponibili e con le competenze necessarie per metter mano al sistema. Inoltre, la struttura del
sistema e la relativa documentazione potrebbero essere inadeguate. Infine, sono molto probabili errori,
duplicazioni e incoerenze dei dati utilizzati dal sistema.
Per questi motivi non è facile decidere cosa fare del sistema legacy. Le possibili strategie sono: continuare a
mantenere il sistema, trasformare il sistema riprogettandolo per migliorarne la manutenibilità e sostituire il
sistema con un nuovo sistema. Quello che in genere si dice è che la scelta della strategia deve dipendere dalla

qualità del sistema e dal suo valore aziendale. Qui sotto sono indicate le possibili combinazioni di qualità e
valore aziendale del sistema. In base alla valutazione, viene consigliata la strategia da applicare
Bassa qualita, basso valore commerciale, questi sistemi dovrebbero essere demoliti.
Bassa qualità, alto valore commerciale questi sistemi forniscono un importante contributo aziendale ma sono
costosi da mantenere; se fosse disponibile un sistema adatto, dovrebbe essere riprogettato o sostituito.
Alta qualità, basso valore commerciale; se la manutenzione non fosse molto costosa, non varrebbe la pena
sostituire questi sistemi, se si rendessero necessarie modifiche costose, il software dovrebbe essere
rollatato
Alta qualità, alto valore aziendale: si dovrebbe continuare il funzionamento utilizzando la normale
manutenzione del sistema.
La figura qui sotto fornisce un esempio di valutazione numerica di dieci sistemi in base alla loro qualita e al
loro valore aziendale.
High business value
Low quality
High business value
High quality
이
이
Business valur
Low business value
Low quality
Low business value
High quality
System quality
Problemi di valutazione del valore aziendale
La valutazione del valore aziendale dipende da molti elementi. Questi elementi sono: l'utilizzo del sistema, i
processi aziendali supportati, l' affidabilità del sistema e l'output del sistema.
Utilizzo del sistema: se i sistemi vengono utilizzati solo occasionalmente o da un numero limitato di persone.
allora il sistema potrebbero avere uno scarso valore aziendale.
Processi aziendali supportati: un sistema può avere un basso valore aziendale se utilizza dei processi aziendali
inefficienti.
Affidabilità del sistema: se un sistema non è affidabile e i problemi colpiscono direttamente i clienti aziendali,
il sistema può avere un basso valore aziendale.
Output del sistema: se l'attività dipende dagli output del sistema (e.g., vendita di prodotti) e gli output sono
buoni, allora il sistema ha un elevato valore aziendale.

Fattori di valutazione ambientale
Ci sono diversi fattori, che coinvolgono tecnologie e persone, che possono far variare la valutazione di
un'azienda. Qui sotto sono indicati alcune problematiche che possono creare dei problemi e delle possibili|
azioni per risolverli o almeno ridurli.
Stabilità del fornitore: il fornitore esiste ancora? Il fornitore è finanziariamente stabile e probabilmente
continuerà ad esistere? Se il fornitore non è più in attività, qualcun altro si occupa della manutenzione dei
sistemi? Se si hanno dei dubbi sulla stabilità del fornitore, può essere utile una ricerca di possibili sostituti.
Tasso di fallimento: l'hardware presenta un tasso elevato di guasti? In base al costo si deve decidere se far
riparare o sostituire l'hardware.
Il software di supporto si blocca e forza il riavvio del sistema? In base al costo si deve decidere se far
correggere il software o sostituirlo con un nuovo software di supporto.
Età: quanti anni hanno l'hardware e il software? Più l'hardware e il software di supporto sono vecchi, più
saranno obsoleti. Il passaggio a un sistema più moderno potrebbe comportare notevoli vantaggi economici
e commerciali.
Prestazione: le prestazioni del sistema sono adeguate? I problemi di prestazioni hanno un effetto significativo
sugli utenti del sistema? Se le prestazioni non sono adeguate e non soddisfano gli utenti, allora devono
essere migliorate per rispettane le aspettative degli utenti.
Costi di manutenzione: quali sono i costi di manutenzione hardware e licenze software di supporto?
L'hardware più vecchio può avere costi di manutenzione più elevati rispetto ai sistemi moderni. Il software
di supporto può avere costi di licenza annuali elevati. In base ai costi bisognerebbe decidere se sostituire il
vecchio hardware e cercare se, ad esempio, è disponibile un software open source o almeno un software
meno costoso che le funzionalità indispensabili fornite dal precedente software.
Requisiti di supporto: quale supporto locale è richiesto dall'hardware e dal software? Se i costi associati a
questo supporto sono elevati, potrebbe valere la pena prendere in considerazione la sostituzione del sistema.
Interoperabilità: ci sono problemi nell'interfacciare il sistema con altri sistemi? Se ci sono problemi di
Interoperabilità è necessario identificare le interazioni che hanno problemi, correggere i problemi ed
eseguire un test completo del sistema che verifichi la risoluzione dei problemi di Interoperabilità.
Fattori di valutazione dell'applicazione
Comprensibilità: quanto è difficile comprendere il codice sorgente del sistema attuale? Quanto sono
complesse le strutture di controllo utilizzate? Le variabili hanno nomi significativi che riflettono la loro
funzione? Se il software non è facilmente comprensibile e le strutture e le variabili sono mal definite, allora
è necessario pianificare delle attività di refactoring che eliminano questi problemi.
Documentazione: quale documentazione di sistema è disponibile? La documentazione è completa, coerente
e aggiornata? Sono disponibili compilatori moderni per il linguaggio di programmazione utilizzato per
sviluppare il sistema? Il linguaggio di programmazione è ancora utilizzato per lo sviluppo di nuovi sistemi? Se
documentazione, compilatori e linguaggi di programmazione non sono adeguati, allora dovranno essere
aggiornati o sostituiti con dei prodotti utili e compatibili per il loro inserimento nel sistema.
Gestione della configurazione: tutte le versioni di tutte le parti del sistema sono gestite da un sistema di
gestione della configurazione? Esiste una descrizione esplicita delle versioni dei componenti utilizzati nel
sistema attuale? Se la gestione della configurazione non risponde alle domande elencate, allora

bisognerebbe operare in modo da rispondere in modo positivo a queste domande aggiornando o sostituendo
il sistema di configurazione e fornendo una descrizione esplicita delle versioni dei componenti.
Dati: esiste un modello di dati esplicito per il sistema? In che misura i dati vengono duplicati tra i file? I dati
utilizzati dal sistema sono aggiornati e coerenti? Se la gestione dei dati non risponde alle domande elencate,
allora bisognerebbe operare in modo da rispondere in modo positivo a queste domande fornendo un
modello di dati esplicito, e ripulendo e aggiornando i dati.
Dati di test: esistono dati di test per il sistema? Esiste una copia dei test di regressione effettuati quando
nuove funzionalità sono state aggiunte al sistema? Se la gestione della configurazione non risponde alle
domande elencate, allora bisognerebbe operare in modo da rispondere in modo positivo a queste domande
fornendo i dati del test per il sistema e una copia dei test di regressione.
Competenze del personale: Ci sono persone disponibili con le competenze necessarie per gestire
l'applicazione? Ci sono persone disponibili che hanno esperienza con il sistema? Se all'interno dell'azienda
non si hanno persone con la necessaria competenza ed esperienza, allora sarebbe necessario far partire
un'attività di ricerca di personale che possa portare velocemente all'acquisizione delle figure necessarie.
Valutazione della misurazione del sistema
Una valutazione del sistema può essere integrata con l'utilizzando di alcune misure che dovrebbero essere a
disposizione dell'azienda, questa integrazione può essere applicata alle misure dell'anno corrente o anche
agli anni precedenti. Qui sotto sono indicati tre tipi di misure del sistema e le problematiche a cui possono
essere esposte.
Il numero di richieste di modifica del sistema: maggiore è questo valore accumulato, minore è la qualità del
sistema.
Il numero di interfacce utente utilizzate dal sistema: più sono le interfacce, più è probabile che vi siano
incoerenze e ridondanze in queste interfacce.
Il volume di dati utilizzati dal sistema: man mano che aumenta il volume dei elaborati dal sistema dati
(numero di file, dimensione del database, ecc.), aumentano anche le incoerenze e gli errori si tali dati. La
pulizia dei vecchi dati è un processo molto costoso e dispendioso in termini di tempo.
Manutenzione del software
Sono le attività che vengono eseguite dopo che il sistema è stato consegnato. Queste attività hanno
l'obiettivo di mantenere in servizio il sistema. La manutenzione normalmente non comporta modifiche
importanti all'architettura del sistema. Le modifiche apportate al software possono: correggere errori di
codifica o di progettazione, fornire miglioramenti per correggere errori di specifica o per soddisfare nuovi |
requisiti. Queste modifiche vengono implementate modificando i componenti esistenti e aggiungendo nuovi
componenti al sistema.

Tipi di manutenzione
Le attività di manutenzioni principali sono: la riparazione dei guasti, adattamento all'ambiente e l'aggiunta e
modifica di funzionalità.
Riparazione dei guasti: modificare un sistema per correggere bug/vulnerabilità e correggere le carenze in
modo da soddisfarne i requisiti.
Adattamento all'ambiente: manutenzione per adattare il software, ad esempio, a un diverso ambiente
operativo. Modificare un sistema in modo che funzioni in un ambiente diverso (computer, sistema operativo,
ecc.) dalla sua implementazione iniziale.
Aggiunta e modifica di funzionalità: modificare il sistema per soddisfare nuove esigenze.
Distribuzione Degli Sforzi di Manutenzione
I costi di manutenzione sono principalmente dovuti all'adattamento a un nuovo ambiente, alla correzione
di errori e all'aggiunta o alla modifica di funzionalità. La figura qui sotto presenta le percentuali dei costi dei
tre diversi tipi di attività di manutenzione.
Ensironmeres
Costi della Manutenzione
Solitamente è più costoso aggiungere nuove funzionalità a un sistema durante la manutenzione piuttosto
che aggiungere le stesse funzionalità durante lo sviluppo. I costi dipendono dal tipo di applicazione,
solitamente sono superiori ai costi di sviluppo e il costo è influenzato da fattori sia tecnici che non tecnici. 1|
costi aumentano man mano che il software viene mantenuto perché la manutenzione diventa sempre più
difficile e i costi sono sempre più alti.
Problemi della Manutenzione
Se la manutenzione viene assegnata a un team che non ha sviluppato il sistema, allora il team deve
comprendere il software del sistema. Se si separano la manutenzione dallo sviluppo, allora non vi è alcun
incentivo per il team di sviluppo a scrivere software mantenibile. Il lavoro di manutenzione del programma è
impopolare e quindi il personale esperto preferisce eseguire altre attività. Il personale addetto alla
manutenzione è spesso inesperto e ha una conoscenza limitata del settore; quindi potrebbe corrompere la
struttura del software, rendendo più difficile l'ulteriore manutenzione. Man mano che i programmi
invecchiano, la loro struttura si degrada e diventano più difficili da modificare e quindi è molto probabile
avere dei costi di supporto elevati.

Previsione sulla Manutenzione
Una previsione sul costo delle attività di manutenzione può essere fatta tenendo conto della storia del
sistema che si sta esaminando. La figura qui sotto indica alcune domande che possono essere utili per fare la
previsione del costo.
Si preoccupa di valutare quali parti del sistema
causare problemi e avere costi di manutenzione ele
Quali parti del sistema
hanno maggiori probabilità
di essere interessate dalle
richieste di modifica?
Quali parti del sistema hanno
mazziori probabilità di essere
Interessate dalle richieste di
modifica?
Quali saranno i costi di
manuteazione della
vita di questo sistema?
Quali saranno i costi per il
mantenimento di questo
sistema nel pross
во апло?
Quante richieste di modifica
si possono prevedere?
Previsione dei Cambiamenti
Richiede la comprensione delle relazioni tra un sistema e il suo ambiente. I sistemi strettamente accoppiati
richiedono cambiamenti ogni volta che l'ambiente cambia.
I fattori che influenzano questa relazione sono: numero e complessità delle interfacce di sistema, numero di
requisiti di sistema intrinsecamente volatili e i processi aziendali in cui viene utilizzato il sistema.
Metriche di complessità e di processo
È possibile effettuare previsioni di manutenibilità valutando la complessità dei componenti del sistema. GlI
studi hanno dimostrato che la maggior parte degli sforzi di manutenzione vengono spesi su un numero
relativamente piccolo di componenti del sistema.
La complessità di un sistema dipende da: complessità della strutture di controllo, complessità della strutture
dati, complessità di oggetti e metodi e la dimensione dei moduli del sistema.
Le metriche di processo possono essere utilizzate per valutare la manutenibilità in base a: numero di richieste
di manutenzione correttiva, tempo medio necessario per l'analisi di impatto, tempo medio impiegato per
implementare una richiesta di modifica e numero di richieste di modifica in sospeso. Se uno o tutti questi
fattori aumentano, ciò potrebbe indicare un calo della manutenibilità.
Reingegnerizzazione del Software
Ristruttura o riscrive parte o tutto un sistema legacy senza modificarne le funzionalità. È applicabile a dei
sottosistemi, di un sistema più grande, che richiedono una manutenzione frequente. La riprogettazione
implica uno sforzo aggiuntivo per renderli più facili da mantenere. Il sistema può essere ristrutturato e ri-
documentato.
Vantaggi della Reingegnerizzazione
Il rischio della reingegnerizzazione è ridotto rispetto allo sviluppo di nuovi software che ha invece un rischio
elevato visto che potrebbero esserci problemi di specifiche, di sviluppo e di personale. Il costo è ridotto visto
che il costo della riprogettazione è spesso significativamente inferiore ai costi di sviluppo di un nuovo
software.

Attività della Reingegnerizzazione
Utilizzando tecniche di ingegneria inversa (reverse engineering) si cerca di capire il comportamento del
software del sistema. Si riorganizzare la struttura del programma e si definiscono i moduli che compongono
il sistema. Se necessario, si traduce il codice in un altro linguaggio di programmazione. Infine, si cerca di
"ripulire" e ristruttura i dati del sistema.
Processo di Reingegnerizzazione
Nei due diagrammi
qui sotto si identificano le attività che possono essere coinvolte in una
reingegnerizzazione del sistema. Ovviamente più attività sono eseguite, più il costo sarà elevato.
Re engineened
Reverse
nodularization
Automated program
TestucurnS
Program and data
vorrestori
Automated source
code conversion
Automated restructuring
with manual changes
Restructuring plus
architectural changes
Increased cost
Riprogettazione dei fattori di costo
I costi di reingegnerizzare di un sistema dipende molto dalla qualità e dalla disponibilità di alcune risorse. In
particolare i costi dipendono da: la qualità del software, gli strumento di supporto disponibili, la qualità dei
dati e la disponibilità di personale esperto. Ovviamente i costi cambiano di molto se il sistema da
reingegnerizzare è stato sviluppato con tecnologie recenti o con tecnologie superate e ormai poco utilizzate.
Refactoring
Il refactoring è il processo di miglioramento di un programma per rallentare il degrado dovuto al
cambiamento. Il refactoring può essere considerate come una manutenzione preventiva che riduce i
problemi dei cambiamenti futuri. Il refactoring implica la modifica di un programma per migliorarne la
struttura, ridurne la complessità o renderlo più facile da comprendere. L'esecuzione del refactoring di un
programma, non dovrebbe aggiungere funzionalità, ma solo migliorare il programma.
Refactoring e Reingegnerizzazione
La reingegnerizzazione avviene dopo che un sistema è stato mantenuto per un certo periodo di tempo e i
costi di manutenzione sono in aumento. Utilizza strumenti automatizzati per elaborare e riprogettare un
sistema legacy per
creare un nuovo sistema più gestibile. Il refactoring è un processo continuo di
miglioramento durante tutto il processo di sviluppo ed evoluzione. Lo scopo è evitare il degrado della
10

struttura e del codice perché ovviamente il degrado aumenta i costi e le difficoltà di manutenzione di un
sistema.
Code Bad Smells - Codifica Scadente o Sbagliata
Codice duplicato: lo stesso codice o uno molto simile possono essere inclusi in punti diversi di un programma.
Queste duplicazioni possono essere rimosse e implementate da un singolo metodo o funzione chiamata
come richiesto.
Metodi lunghi: se un metodo è troppo lungo, allora dovrebbe essere riprogettato come un numero di metodi
più corti.
Switch case: lo stesso codice dello switch può essere presente di diverse parti di un programma. Se si vuole
aggiungere o rimuovere un case in uno switch è necessario individuare tutte le copie dello switch e
correggerle. Nei linguaggi orientati agli oggetti, è spesso possibile utilizzare il polimorfismo per ottenere lo
stesso risultato.
Raggruppamento dei dati: i raggruppamenti dei dati si verificano quando lo stesso gruppo di elementi dei
dati si presenta in più punti in un programma. Questi gruppi possono essere sostituiti con un oggetto
condiviso che incapsula tutti i dati.
Generalità speculativa: spesso gli sviluppatori includono generalità (e.g., nuovi elementi che per il momento
non sono utilizzati) che si pensa che potrebbero essere necessarie in futuro nel programma. La loro presenza
crea solo delle perdite di tempo per le persone che devono capire lo scopo della loro presenza. Le generalità
devono essere semplicemente rimosse.